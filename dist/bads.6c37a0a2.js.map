{"mappings":"AUQO,SAAS,EAAM,CAAA,CAAa,CAAA,CAAe,CAAA,EAChD,OAAO,KAAK,GAAA,CAAI,EAAK,KAAK,GAAA,CAAI,EAAO,GACvC,CCCO,IAAM,EAAN,MACL,UAAY,CAAA,CADO,AAEnB,CAAA,MAAQ,CADI,AAEZ,CAAA,KAAO,CADC,AAER,CAAA,GAAK,CADE,AAEP,CAAA,YAAc,CADT,AAIL,CAAA,IAHc,AAId,CAAA,QADA,AAEA,CAAA,MADA,AAEA,CAAA,QADA,AAQA,CAAA,QAAQ,CAAA,CAAmB,CACzB,GAAI,CAAC,IAAA,CAAK,SAAA,CAAV,OAEA,IAAI,EAAY,CAAA,EAEhB,GAAI,IAAA,CAAK,QAAA,EAAY,IAAA,CAAK,MAAA,CAAQ,CAChC,IAAA,CAAK,WAAA,EAAe,EACpB,IAAM,EAAiB,EAAM,EAAG,IAAA,CAAK,WAAA,CAAc,IAAA,CAAK,QAAA,CAAU,GAG5D,EAAgB,AADtB,CAAA,EAAY,GAAkB,CAAA,EACI,EAAI,IAAA,CAAK,MAAA,CAAO,EAClD,CAAA,IAAA,CAAK,KAAA,CAAQ,IAAA,CAAK,IAAA,CAAA,AAAQ,CAAA,IAAA,CAAK,EAAA,CAAK,IAAA,CAAK,IAAA,AAAA,EAAQ,CACnD,MAAA,GAAW,IAAA,CAAK,IAAA,CAAM,KDIL,EAAW,EAAW,EAdA,CCWrC,CAAA,IAAA,CAAK,KAAA,EDGU,ECHG,IAAA,CAAK,KAAA,CDGG,ECHI,IAAA,CAAK,EAAA,CDGE,ECHE,AAAY,GAAZ,IAAA,CAAK,IAAA,CDVxC,AAAA,CAAA,GADiC,EAevB,EAAI,KAAK,GAAA,CAAI,CAAC,ECJ2B,GDV/C,EAcA,EAdS,EAcN,GCHP,KAAK,KAAA,CAAM,IAAA,CAAK,KAAK,IAAM,IAAA,CAAK,EAAA,GAClC,IAAA,CAAK,KAAA,CAAQ,IAAA,CAAK,EAAlB,CACA,EAAY,CAAA,EAEhB,MAEE,IAAA,CAAK,KAAA,CAAQ,IAAA,CAAK,EAAlB,CACA,EAAY,CAAA,CAGV,CAAA,GACF,IAAA,CAAK,IAAA,GAIP,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,KAAA,CAAO,EAC9B,CAGA,MAAO,CACL,IAAA,CAAK,SAAA,CAAY,CAAA,CACnB,CAUA,OACE,CAAA,CACA,CAAA,CACA,CAAE,KAAAW,CAAAA,CAAAA,SAAM,CAAA,CAAA,OAAU,CAAA,CAAA,QAAQ,CAAA,CAAA,SAAS,CAAA,CAAS,CAC5C,CACA,IAAA,CAAK,IAAA,CAAO,IAAA,CAAK,KAAA,CAAQ,EACzB,IAAA,CAAK,EAAA,CAAK,EACV,IAAA,CAAK,IAAA,CAAOA,EACZ,IAAA,CAAK,QAAA,CAAW,EAChB,IAAA,CAAK,MAAA,CAAS,EACd,IAAA,CAAK,WAAA,CAAc,EACnB,IAAA,CAAK,SAAA,CAAY,CAAA,EAEjB,MACA,IAAA,CAAK,QAAA,CAAW,CAClB,CACF,EE/Ea,EAAN,MAWL,YACU,CAAA,CACA,CAAA,CACR,CAAA,WAAE,EAAa,CAAA,CAAA,CAAM,SAAU,EAAgB,GAAA,CAAI,CAAI,CAAC,CAAA,CACxD,CACA,GAJQ,IAAA,CAAA,OAAA,CAAA,EACA,IAAA,CAAA,OAAA,CAAA,EAGJ,EAAY,KD1BlB,MAGI,CCwBA,CAAA,IAAA,CAAK,eAAA,ED3BT,EC2BoC,IAAA,CAAK,MAAA,CDvBlC,SAAA,GAAyB,CAAA,EAC9B,IAAI,EAAU,IAAd,CACA,aAAa,GACb,EAAQ,WAAW,KACjB,EAAQ,KAAR,EACA,EAAS,KAAA,CAAM,EAAS,EAC1B,ECiB+C,EDhBjD,GCkBQ,IAAA,CAAK,OAAA,YAAmB,OAC1B,OAAO,gBAAA,CAAiB,SAAU,IAAA,CAAK,eAAA,CAAiB,CAAA,IAExD,IAAA,CAAK,qBAAA,CAAwB,IAAI,eAAe,IAAA,CAAK,eAAe,EACpE,IAAA,CAAK,qBAAA,CAAsB,OAAA,CAAQ,IAAA,CAAK,OAAO,GAGjD,IAAA,CAAK,qBAAA,CAAwB,IAAI,eAAe,IAAA,CAAK,eAAe,EACpE,IAAA,CAAK,qBAAA,CAAsB,OAAA,CAAQ,IAAA,CAAK,OAAO,CACjD,CAEA,IAAA,CAAK,MAAA,EACP,CA9BA,MAAQ,CA8BR,AA7BA,CAAA,OAAS,CADD,AAER,CAAA,aAAe,CADN,AAET,CAAA,YAAc,CADC,AAIP,CAAA,eAHM,AAIN,CAAA,qBADA,AAEA,CAAA,qBADA,AAyBR,CAAA,SAAU,CACR,IAAA,CAAK,qBAAA,EAAuB,aAC5B,IAAA,CAAK,qBAAA,EAAuB,aAExB,IAAA,CAAK,OAAA,GAAY,QAAU,IAAA,CAAK,eAAA,EAClC,OAAO,mBAAA,CAAoB,SAAU,IAAA,CAAK,eAAA,CAAiB,CAAA,EAE/D,CAEA,OAAS,KACP,IAAA,CAAK,eAAA,GACL,IAAA,CAAK,eAAA,EACP,CADuB,AAGvB,CAAA,gBAAkB,KACZ,IAAA,CAAK,OAAA,YAAmB,QAC1B,IAAA,CAAK,KAAA,CAAQ,OAAO,UAApB,CACA,IAAA,CAAK,MAAA,CAAS,OAAO,WAArB,GAEA,IAAA,CAAK,KAAA,CAAQ,IAAA,CAAK,OAAA,CAAQ,WAA1B,CACA,IAAA,CAAK,MAAA,CAAS,IAAA,CAAK,OAAA,CAAQ,YAA3B,CAEJ,CADE,AAGF,CAAA,gBAAkB,KACZ,IAAA,CAAK,OAAA,YAAmB,QAC1B,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,OAAA,CAAQ,YAAjC,CACA,IAAA,CAAK,WAAA,CAAc,IAAA,CAAK,OAAA,CAAQ,WAAhC,GAEA,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,OAAA,CAAQ,YAAjC,CACA,IAAA,CAAK,WAAA,CAAc,IAAA,CAAK,OAAA,CAAQ,WAAhC,CAEJ,CADE,AAGF,KAAI,OAAQ,CACV,MAAO,CACL,EAAG,IAAA,CAAK,WAAA,CAAc,IAAA,CAAK,KADtB,CAEL,EAAG,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,MADD,AAE7B,CACF,CACF,EC3Ea,EAAN,MACG,OAGJ,CAAC,CAJc,AAWnB,CAAA,KAAK,CAAA,CAAA,GAAkB,CAAA,CAAiB,CACtC,IAAI,EAAY,IAAA,CAAK,MAAA,CAAO,EAAK,EAAK,EAAtC,CACA,IAAA,IAAS,EAAI,EAAG,EAAS,EAAU,MAAA,CAAQ,EAAI,EAAQ,IACrD,CAAA,CAAU,EAAC,MAAO,EAEtB,CAQA,GAAwC,CAAA,CAAe,CAAA,CAAQ,CAK7D,OAHA,IAAA,CAAK,MAAA,CAAO,EAAK,EAAG,KAAK,IAAQ,CAAA,IAAA,CAAK,MAAA,CAAO,EAAK,CAAI,CAAC,EAAE,AAAzD,EAGO,KACL,IAAA,CAAK,MAAA,CAAO,EAAK,CAAI,IAAA,CAAK,MAAA,CAAO,EAAK,EAAG,OAAO,AAAC,GAAM,IAAO,EAChE,CACF,CAOA,IAAyC,CAAA,CAAe,CAAA,CAAc,CACpE,IAAA,CAAK,MAAA,CAAO,EAAK,CAAI,IAAA,CAAK,MAAA,CAAO,EAAK,EAAG,OAAO,AAAC,GAAM,IAAa,EACtE,CAKA,SAAU,CACR,IAAA,CAAK,MAAA,CAAS,CAAC,CACjB,CACF,ECvDM,EAAc,IAAM,EACpB,EAA2C,CAAE,QAAS,CAAA,CAAM,EAErD,EAAN,MAeL,YACU,CAAA,CACA,EAAU,CAAE,gBAAiB,EAAG,gBAAiB,CAAE,CAAA,CAC3D,CAFQ,IAAA,CAAA,OAAA,CAAA,EACA,IAAA,CAAA,OAAA,CAAA,EAER,OAAO,gBAAA,CAAiB,SAAU,IAAA,CAAK,cAAA,CAAgB,CAAA,GACvD,IAAA,CAAK,cAAA,GAEL,IAAA,CAAK,OAAA,CAAQ,gBAAA,CAAiB,QAAS,IAAA,CAAK,OAAA,CAAS,GACrD,IAAA,CAAK,OAAA,CAAQ,gBAAb,CACE,aACA,IAAA,CAAK,YADL,CAEA,GAEF,IAAA,CAAK,OAAA,CAAQ,gBAAb,CACE,YACA,IAAA,CAAK,WADL,CAEA,GAEF,IAAA,CAAK,OAAA,CAAQ,gBAAA,CAAiB,WAAY,IAAA,CAAK,UAAA,CAAY,EAC7D,CAjCA,WAAa,CACX,EAAG,EACH,EAAG,CACL,CADK,AAEL,CAAA,UAAY,CACV,EAAG,EACH,EAAG,CACL,CADK,AAEL,CAAA,OAAS,CACP,MAAO,EACP,OAAQ,CACV,CADU,AAEF,CAAA,QAAU,IAAI,CADtB,AA8BA,CAAA,GAAG,CAAA,CAAe,CAAA,CAAiC,CACjD,OAAO,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,EAAO,EAChC,CAGA,SAAU,CACR,IAAA,CAAK,OAAA,CAAQ,OAAA,GAEb,OAAO,mBAAA,CAAoB,SAAU,IAAA,CAAK,cAAA,CAAgB,CAAA,GAE1D,IAAA,CAAK,OAAA,CAAQ,mBAAA,CAAoB,QAAS,IAAA,CAAK,OAAA,CAAS,GACxD,IAAA,CAAK,OAAA,CAAQ,mBAAb,CACE,aACA,IAAA,CAAK,YADL,CAEA,GAEF,IAAA,CAAK,OAAA,CAAQ,mBAAb,CACE,YACA,IAAA,CAAK,WADL,CAEA,GAEF,IAAA,CAAK,OAAA,CAAQ,mBAAb,CACE,WACA,IAAA,CAAK,UADL,CAEA,EAEJ,CAOA,aAAe,AAAC,IAEd,GAAM,CAAA,QAAE,CAAA,CAAA,QAAS,CAAA,CAAQ,CAAI,EAAM,aAAA,CAC/B,EAAM,aAAA,CAAc,EAAC,CACrB,CAEJ,CAAA,IAAA,CAAK,UAAA,CAAW,CAAA,CAAI,EACpB,IAAA,CAAK,UAAA,CAAW,CAAA,CAAI,EAEpB,IAAA,CAAK,SAAA,CAAY,CACf,EAAG,EACH,EAAG,CACL,EAEA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,SAAU,CAC1B,OAAQ,EACR,OAAQ,EACR,MAAA,CACF,EACF,CADG,AAIH,CAAA,YAAc,AAAC,IAEb,GAAM,CAAA,QAAE,CAAA,CAAA,QAAS,CAAA,CAAQ,CAAI,EAAM,aAAA,CAC/B,EAAM,aAAA,CAAc,EAAC,CACrB,EAEE,EAAS,CAAE,CAAA,EAAU,IAAA,CAAK,UAAA,CAAW,CAAA,AAAA,EAAK,IAAA,CAAK,OAAA,CAAQ,eAA7D,CACM,EAAS,CAAE,CAAA,EAAU,IAAA,CAAK,UAAA,CAAW,CAAA,AAAA,EAAK,IAAA,CAAK,OAAA,CAAQ,eAA7D,AAEA,CAAA,IAAA,CAAK,UAAA,CAAW,CAAA,CAAI,EACpB,IAAA,CAAK,UAAA,CAAW,CAAA,CAAI,EAEpB,IAAA,CAAK,SAAA,CAAY,CACf,EAAG,EACH,EAAG,CACL,EAEA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,SAAU,CAC1B,OAAA,EACA,OAAA,EACA,MAAA,CACF,EACF,CADG,AAGH,CAAA,WAAa,AAAC,IACZ,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,SAAU,CAC1B,OAAQ,IAAA,CAAK,SAAA,CAAU,CADG,CAE1B,OAAQ,IAAA,CAAK,SAAA,CAAU,CADA,CAEvB,MAAA,CACF,EACF,CADG,AAIH,CAAA,QAAU,AAAC,IACT,GAAI,CAAA,OAAE,CAAA,CAAA,OAAQ,CAAA,CAAA,UAAQ,CAAA,CAAU,CAAI,EAE9B,EACJ,AAAc,IAAd,EAAkB,EAAc,AAAc,IAAd,EAAkB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAQ,EAClE,EACJ,AAAc,IAAd,EAAkB,EAAc,AAAc,IAAd,EAAkB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAS,EAEzE,GAAU,EACV,GAAU,EAEV,GAAU,IAAA,CAAK,OAAA,CAAQ,eAAvB,CACA,GAAU,IAAA,CAAK,OAAA,CAAQ,eAAvB,CAEA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,SAAU,CAAE,OAAA,EAAQ,OAAA,EAAQ,MAAA,CAAM,EACtD,CADuD,AAGvD,CAAA,eAAiB,KACf,IAAA,CAAK,MAAA,CAAS,CACZ,MAAO,OAAO,UADF,CAEZ,OAAQ,OAAO,WADD,AAEhB,CACF,CADE,AAEJ,ECpIM,EAAgB,AAAC,GAAc,KAAK,GAAA,CAAI,EAAG,MAAQ,KAAK,GAAA,CAAI,EAAG,IAAM,IAE9D,EAAN,MACG,aAA0B,CAAA,CADjB,AAET,CAAA,WAAa,CAAA,CADa,AAE1B,CAAA,UAAY,CAAA,CADC,AAEb,CAAA,8BAAgC,CAAA,CADpB,AAEZ,CAAA,sBAA8D,IAD9B,AAEhC,CAAA,OAAwB,IADsC,AAMtE,CAAA,UALgC,AAShC,CAAA,KAAO,CAJP,AAeA,CAAA,SAAqB,CAAC,CAXf,AAeP,CAAA,aAAe,CAJO,AAQtB,CAAA,SAAW,CAJI,AAQf,CAAA,UAAwB,CAJb,AAQX,CAAA,OAJwB,AAWxB,CAAA,YAPA,AAWA,CAAA,cAJA,AAOiB,CAAA,QAAU,IAAI,CAH/B,AAIiB,CAAA,QAAU,IAAI,CADQ,AAG9B,CAAA,UAF8B,AAGtB,CAAA,aADR,AAGT,aAAY,CAAA,QACV,EAAU,MAAA,CAAA,QACV,EAAU,SAAS,eADT,CAAA,aAEV,EAAe,CAAA,CAAA,YACf,EAAc,CAAA,CAAA,CAAA,UACd,EAAY,CAAA,CAAA,CAAA,cACZ,EAAgB,IAAA,CAAA,qBAChB,EAAuB,GAAA,CAAA,SACvB,CADuB,CAAA,OAEvB,CADA,CAEA,KAAAA,EAAO,EADP,CAAA,SAEA,EAAW,CAAA,CAAA,CAAA,YACX,EAAc,UAAA,CAAA,mBACd,EAAqB,AAAgB,eAAhB,EAA+B,OAAS,UAAA,CAAA,gBAC7D,EAAkB,CAAA,CAAA,gBAClB,EAAkB,CAAA,CAAA,WAClB,EAAa,CAAA,CAAA,CAAA,QACb,CADa,CAAA,cAEb,CADA,CAAA,WAEA,EAAa,CAAA,CAAA,CAAA,QACb,EAAU,CAAA,CAAA,CAAA,QACV,EAAU,CAAA,CAAA,CAAA,WACV,EAAa,CAAA,CAAA,CAAA,kBACb,EAAoB,CAAA,CAAA,CAAA,gCAEpB,EAAkC,CAAA,CAAA,CAAA,gBAClC,EAAkB,CAAA,CAAA,sBAClB,EAAwB,CAAA,CAAA,CAC1B,CAAkB,CAAC,CAAA,CAAG,CAEpB,OAAO,YAAA,CPvHE,SO0HL,AAAC,GAAW,IAAY,SAAS,eAAA,EACnC,CAAA,EAAU,MADZ,EAKI,AAAoB,UAApB,OAAO,GAAyB,AAAkB,YAAlB,OAAO,EACzC,EAAS,EACA,AAAkB,YAAlB,OAAO,GAAyB,AAAoB,UAApB,OAAO,GAChD,CAAA,EAAW,CAAA,EAIb,IAAA,CAAK,OAAA,CAAU,CACb,QAAA,EACA,QAAA,EACA,aAAA,EACA,YAAA,EACA,UAAA,EACA,cAAA,EACA,qBAAA,EACA,SAAA,EACA,OAAA,EACA,KAAAA,EACA,SAAA,EACA,mBAAA,EACA,YAAA,EACA,gBAAA,EACA,gBAAA,EACA,WAAA,EACA,QAAA,EACA,cAAA,EACA,WAAA,EACA,QAAA,EACA,QAAA,EACA,WAAA,EACA,kBAAA,EACA,gBAAA,EACA,sBAAA,CACF,EAGA,IAAA,CAAK,UAAA,CAAa,IAAI,EAAW,EAAS,EAAS,CAAE,WAAA,CAAW,GAGhE,IAAA,CAAK,eAAA,GAGL,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,YAA/C,CAGA,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,gBAAA,CAAiB,SAAU,IAAA,CAAK,cAAA,CAAgB,CAAA,GAErE,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,gBAAA,CAAiB,YAAa,IAAA,CAAK,WAAA,CAAa,CACnE,QAAS,CAAA,CACX,GAEI,CAAA,IAAA,CAAK,OAAA,CAAQ,OAAA,EAAW,IAAA,CAAK,OAAA,CAAQ,qBAAA,AAAA,GACvC,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,gBAArB,CACE,QACA,IAAA,CAAK,OADL,CAEA,CAAA,GAIJ,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,gBAArB,CACE,cACA,IAAA,CAAK,aADL,CAEA,CAAA,GAIF,IAAA,CAAK,aAAA,CAAgB,IAAI,EAAc,EAA6B,CAClE,gBAAA,EACA,gBAAA,CACF,GACA,IAAA,CAAK,aAAA,CAAc,EAAA,CAAG,SAAU,IAAA,CAAK,eAAe,EAEhD,IAAA,CAAK,OAAA,CAAQ,UAAA,GACf,IAAA,CAAK,aAAA,GACL,IAAA,CAAK,WAAA,CAAY,gBAAA,CAAiB,gBAAiB,IAAA,CAAK,eAAA,CAAiB,CACvE,QAAS,CAAA,CACX,IAGE,IAAA,CAAK,OAAA,CAAQ,OAAA,EACf,CAAA,IAAA,CAAK,MAAA,CAAS,sBAAsB,IAAA,CAAK,GAAG,CAAA,CAEhD,CAKA,SAAU,CACR,IAAA,CAAK,OAAA,CAAQ,OAAA,GAEb,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,mBAArB,CACE,SACA,IAAA,CAAK,cADL,CAEA,CAAA,GAGF,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,mBAAA,CAAoB,YAAa,IAAA,CAAK,WAAA,CAAa,CACtE,QAAS,CAAA,CACX,GAEA,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,mBAArB,CACE,cACA,IAAA,CAAK,aADL,CAEA,CAAA,GAGE,CAAA,IAAA,CAAK,OAAA,CAAQ,OAAA,EAAW,IAAA,CAAK,OAAA,CAAQ,qBAAA,AAAA,GACvC,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,mBAArB,CACE,QACA,IAAA,CAAK,OADL,CAEA,CAAA,GAIJ,IAAA,CAAK,aAAA,CAAc,OAAA,GACnB,IAAA,CAAK,UAAA,CAAW,OAAA,GAEhB,IAAA,CAAK,gBAAA,GAED,IAAA,CAAK,MAAA,EACP,qBAAqB,IAAA,CAAK,MAAM,CAEpC,CAWA,GAAG,CAAA,CAAmB,CAAA,CAAe,CACnC,OAAO,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,EAAO,EAChC,CAUA,IAAI,CAAA,CAAmB,CAAA,CAAe,CACpC,OAAO,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,EAAO,EACjC,CAEQ,YAAc,AAAC,IACjB,AAAE,aAAa,aACb,AAAqB,WAArB,IAAA,CAAK,WAAA,EAA4B,AAAqB,CAAA,IAArB,IAAA,CAAK,WAAA,EACxC,EAAE,eAAA,EAGR,CADE,AAGM,CAAA,uBAAyB,KAC/B,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,aAArB,CACE,IAAI,YAAY,YAAa,CAC3B,QAAS,IAAA,CAAK,OAAA,CAAQ,OAAA,GAAY,OAElC,OAAQ,CACN,eAAgB,CAAA,CAClB,CACF,GAEJ,CADE,AAGF,KAAI,UAAW,CACb,IAAM,EAAW,IAAA,CAAK,YAAA,CAAe,aAAe,aACpD,OAAO,iBAAiB,IAAA,CAAK,WAAW,CAAA,CACtC,EADF,AAGF,CAEQ,eAAgB,CAClB,CAAC,SAAU,OAAM,CAAE,QAAA,CAAS,IAAA,CAAK,QAAQ,EAC3C,IAAA,CAAK,YAAA,GAEL,IAAA,CAAK,aAAA,EAET,CAEQ,gBAAkB,AAAC,IACrB,EAAM,YAAA,CAAa,QAAA,CAAS,aAC9B,IAAA,CAAK,aAAA,EAET,CADE,AAGM,CAAA,UAAU,CAAA,CAAgB,CAG5B,IAAA,CAAK,YAAA,CACP,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,QAAA,CAAS,CAAE,KAAM,EAAQ,SAAU,SAAU,GAElE,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,QAAA,CAAS,CAAE,IAAK,EAAQ,SAAU,SAAU,EAErE,CAEQ,QAAU,AAAC,IAIjB,IAAM,EAAiB,AAHV,EAAM,YAAA,GAGS,MAA5B,CACE,AAAC,GAAS,aAAgB,mBAAqB,EAAK,YAAA,CAAa,SAGnE,GAAI,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAS,CACxB,IAAM,EAAS,EAAe,IAA9B,CAAmC,AAAC,GAClC,EAAK,YAAA,CAAa,SAAS,SAAS,MAEtC,GAAI,EAAQ,CACV,IAAM,EAAO,EAAO,YAAA,CAAa,QAEjC,GAAI,EAAM,CACR,IAAM,EACJ,AAAgC,UAAhC,OAAO,IAAA,CAAK,OAAA,CAAQ,OAAA,EAAwB,IAAA,CAAK,OAAA,CAAQ,OAAA,CACrD,IAAA,CAAK,OAAA,CAAQ,OAAA,CACb,KAHN,EAKM,EAAS,CAAA,CAAA,EAAI,EAAK,KAAA,CAAM,IAAG,CAAE,EAAE,CAAA,CAArC,CAEA,IAAA,CAAK,QAAA,CAAS,EAAQ,EACxB,CACF,CACF,CAEI,IAAA,CAAK,OAAA,CAAQ,qBAAA,EACM,EAAe,IAApC,CACE,AAAC,GAAS,EAAK,IAAA,GAAS,OAAO,QAAA,CAAS,IADN,GAKlC,IAAA,CAAK,KAAA,EAGX,CADE,AAGM,CAAA,cAAgB,AAAC,IACnB,AAAiB,IAAjB,EAAM,MAAA,EACR,IAAA,CAAK,KAAA,EAET,CADE,AAGM,CAAA,gBAAkB,AAAC,IACzB,GACE,AAAsC,YAAtC,OAAO,IAAA,CAAK,OAAA,CAAQ,aAAA,EACpB,AAAqC,CAAA,IAArC,IAAA,CAAK,OAAA,CAAQ,aAAA,CAAc,GAE3B,OAEF,GAAM,CAAA,OAAE,CAAA,CAAA,OAAQ,CAAA,CAAA,MAAQ,CAAA,CAAM,CAAI,EAKlC,GAHA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,iBAAkB,CAAE,OAAA,EAAQ,OAAA,EAAQ,MAAA,CAAM,GAGxD,EAAM,OAAA,EAEN,EAAM,oBAAA,CAFV,OAIA,IAAM,EAAU,EAAM,IAAA,CAAK,QAAA,CAAS,SAC9B,EAAU,EAAM,IAAA,CAAK,QAAA,CAAS,QAEpC,CAAA,IAAA,CAAK,UAAA,CAAa,AAAe,eAAf,EAAM,IAAA,EAAyB,AAAe,cAAf,EAAM,IAAA,CAWvD,IAAM,EAAe,AAAW,IAAX,GAAgB,AAAW,IAAX,EAUrC,GAPE,IAAA,CAAK,OAAA,CAAQ,SAAA,EACb,GACA,AAAe,eAAf,EAAM,IAAA,EACN,GACA,CAAC,IAAA,CAAK,SAAA,EACN,CAAC,IAAA,CAAK,QANR,CAQiB,YACf,IAAA,CAAK,KAAA,GAUP,IAAM,EACH,AAAoC,aAApC,IAAA,CAAK,OAAA,CAAQ,kBAAA,EAAqC,AAAW,IAAX,GAClD,AAAoC,eAApC,IAAA,CAAK,OAAA,CAAQ,kBAAA,EAAuC,AAAW,IAAX,EAEvD,GAAI,GAAgB,EAElB,OAIF,IAAI,EAAe,EAAM,YAAA,GACzB,EAAe,EAAa,KAAA,CAAM,EAAG,EAAa,OAAA,CAAQ,IAAA,CAAK,WAAW,GAE1E,IAAM,EAAU,IAAA,CAAK,OAAA,CAAQ,OAA7B,CAEA,GACI,EAAa,IADjB,CAEI,AAAC,GACC,aAAgB,aACd,CAAA,AAAmB,YAAnB,OAAO,GAA0B,IAAU,IAC3C,EAAK,YAAA,GAAe,uBACnB,GAAW,EAAK,YAAA,GAAe,6BAC/B,GAAW,EAAK,YAAA,GAAe,6BAC/B,IAAA,CAAK,OAAA,CAAQ,iBAAA,EACZ,IAAA,CAAK,iBAAA,CAAkB,EAAM,CAAE,OAAA,EAAQ,OAAA,CAAO,EAAA,GAGtD,OAEF,GAAI,IAAA,CAAK,SAAA,EAAa,IAAA,CAAK,QAAA,CAAU,CAC/B,EAAM,UAAA,EACR,EAAM,cAAA,GAER,MACF,CAMA,GAAI,CAHD,CAAA,IAAA,CAAK,OAAA,CAAQ,SAAA,EAAa,GAC1B,IAAA,CAAK,OAAA,CAAQ,WAAA,EAAe,CAF/B,EAIe,CACb,IAAA,CAAK,WAAA,CAAc,SACnB,IAAA,CAAK,OAAA,CAAQ,IAAA,GAEb,EAAM,oBAAA,CAAuB,CAAA,EAC7B,MACF,CAEA,IAAI,EAAQ,CACR,AAAoC,CAAA,SAApC,IAAA,CAAK,OAAA,CAAQ,kBAAA,CACf,EAAQ,KAAK,GAAA,CAAI,GAAU,KAAK,GAAA,CAAI,GAAU,EAAS,EAC9C,AAAoC,eAApC,IAAA,CAAK,OAAA,CAAQ,kBAAA,EACtB,CAAA,EAAQ,CADV,EAKE,CAAA,CAAC,IAAA,CAAK,OAAA,CAAQ,UAAA,EACd,IAAA,CAAK,OAAA,CAAQ,QAAA,EACZ,IAAA,CAAK,OAAA,CAAQ,OAAA,GAAY,QACxB,IAAA,CAAK,KAAA,CAAQ,GACX,CAAA,IAAA,CAAK,cAAA,CAAiB,GAAK,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,KAAA,EACrD,AAAwB,IAAxB,IAAA,CAAK,cAAA,EAAwB,EAAS,GACtC,IAAA,CAAK,cAAA,GAAmB,IAAA,CAAK,KAAA,EAAS,EAAS,CAAA,CAAA,GAGpD,CAAA,EAAM,oBAAA,CAAuB,CAAA,CAV/B,EAcI,EAAM,UAAA,EACR,EAAM,cAAA,GAGR,IAAM,EAAc,GAAW,IAAA,CAAK,OAAA,CAAQ,SAA5C,CACM,EAAa,GAAW,AAAe,aAAf,EAAM,IAAA,AAIhC,CAFoB,GAItB,CAAA,EACE,KAAK,IAAA,CAAK,IAAA,CAAK,QAAQ,EACvB,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,IAAA,CAAK,QAAQ,EAAG,IAAA,CAAK,OAAA,CAAQ,oBAAoB,CAAA,EAGvE,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,YAAA,CAAe,EAAO,CACvC,aAAc,CAAA,EACd,GAAI,EACA,CACE,KAAM,AAbU,EAaQ,IAAA,CAAK,OAAA,CAAQ,aAAA,CAAgB,CACvD,EACA,CACE,KAAM,IAAA,CAAK,OAAA,CAAQ,IADrB,CAEE,SAAU,IAAA,CAAK,OAAA,CAAQ,QADJ,CAEnB,OAAQ,IAAA,CAAK,OAAA,CAAQ,MADE,AAEzB,CADuB,AAE7B,EACF,CADG,AAMH,CAAA,QAAS,CACP,IAAA,CAAK,UAAA,CAAW,MAAA,GAChB,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,YAA/C,CACA,IAAA,CAAK,IAAA,EACP,CAEQ,MAAO,CACb,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,SAAU,IAAI,CAClC,CAEQ,eAAiB,KAMvB,GALmC,OAA/B,IAAA,CAAK,qBAAA,GACP,aAAa,IAAA,CAAK,qBAAqB,EACvC,IAAA,CAAK,qBAAA,CAAwB,MAG3B,IAAA,CAAK,6BAAA,CAA+B,CACtC,IAAA,CAAK,6BAAA,CAAgC,CAAA,EACrC,MACF,CAEA,GAAI,AAAqB,CAAA,IAArB,IAAA,CAAK,WAAA,EAAyB,AAAqB,WAArB,IAAA,CAAK,WAAA,CAA0B,CAC/D,IAAM,EAAa,IAAA,CAAK,cAAxB,AACA,CAAA,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,YAA/C,CACA,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,QAAzB,CACA,IAAA,CAAK,QAAA,CAAW,IAAA,CAAK,cAAA,CAAiB,EACtC,IAAA,CAAK,SAAA,CAAY,KAAK,IAAtB,CACE,IAAA,CAAK,cAAA,CAAiB,GAGpB,AAAC,IAAA,CAAK,SAAA,EACR,CAAA,IAAA,CAAK,WAAA,CAAc,QADrB,EAIA,IAAA,CAAK,IAAA,GAED,AAAkB,IAAlB,IAAA,CAAK,QAAA,EACP,CAAA,IAAA,CAAK,qBAAA,CAAwB,WAAW,KACtC,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,QAAzB,CACA,IAAA,CAAK,QAAA,CAAW,EAChB,IAAA,CAAK,WAAA,CAAc,CAAA,EACnB,IAAA,CAAK,IAAA,EACP,EAAG,IAAH,CAEJ,CACF,CADE,AAGM,CAAA,OAAQ,CACd,IAAA,CAAK,QAAA,CAAW,CAAA,EAChB,IAAA,CAAK,WAAA,CAAc,CAAA,EACnB,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,YAA/C,CACA,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,QAAA,CAAW,EACpC,IAAA,CAAK,OAAA,CAAQ,IAAA,EACf,CAKA,OAAQ,CACN,GAAK,IAAA,CAAK,SAAA,EAEV,GAAI,IAAA,CAAK,OAAA,CAAQ,UAAA,CAAY,YAC3B,IAAA,CAAK,WAAA,CAAY,KAAA,CAAM,cAAA,CAAe,YAIxC,IAAA,CAAK,aAAA,GACP,CAEQ,eAAgB,CACjB,IAAA,CAAK,SAAA,GAEV,IAAA,CAAK,KAAA,GACL,IAAA,CAAK,SAAA,CAAY,CAAA,EACjB,IAAA,CAAK,IAAA,GACP,CAKA,MAAO,CACL,IAAI,IAAA,CAAK,SAAA,EAET,GAAI,IAAA,CAAK,OAAA,CAAQ,UAAA,CAAY,YAC3B,IAAA,CAAK,WAAA,CAAY,KAAA,CAAM,WAAA,CAAY,WAAY,QAIjD,IAAA,CAAK,YAAA,GACP,CAEQ,cAAe,CACjB,IAAA,CAAK,SAAA,GAET,IAAA,CAAK,KAAA,GACL,IAAA,CAAK,SAAA,CAAY,CAAA,EACjB,IAAA,CAAK,IAAA,GACP,CAOA,IAAM,AAAC,IACL,IAAM,EAAY,EAAQ,CAAA,IAAA,CAAK,IAAA,EAAQ,CAAA,CACvC,CAAA,IAAA,CAAK,IAAA,CAAO,EAEZ,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,AAAY,KAAZ,GAEjB,IAAA,CAAK,OAAA,CAAQ,OAAA,EACf,CAAA,IAAA,CAAK,MAAA,CAAS,sBAAsB,IAAA,CAAK,GAAG,CAAA,CAEhD,CADE,AAuBF,CAAA,SACE,CAAA,CACA,CAAA,OACE,EAAS,CAAA,CAAA,UACT,EAAY,CAAA,CAAA,CAAA,KACZ,EAAO,CAAA,CAAA,CAAA,aACP,EAAe,CAAA,CAAA,CACf,KAAAA,EAAO,EAAe,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAO,KAD3B,CAAA,CAAA,SAEf,EAAW,EAAe,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAW,KADR,CAAA,CAAA,OAE1C,EAAS,EAAe,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAS,KADI,CAAA,CAAA,QAElD,CAD8C,CAAA,WAE9C,CADA,CAAA,MAEA,EAAQ,CAAA,CAAA,CAAA,SACR,CADQ,CAEV,CAAqB,CAAC,CAAA,CACtB,CACA,GAAA,CAAK,IAAA,CAAK,SAAA,GAAa,IAAA,CAAK,QAAA,EAAc,GAG1C,GACE,AAAkB,UAAlB,OAAO,GACP,CAAC,MAAO,OAAQ,QAAS,IAAG,CAAE,QAAA,CAAS,GAEvC,EAAS,OACX,GACE,AAAkB,UAAlB,OAAO,GACP,CAAC,SAAU,QAAS,MAAK,CAAE,QAAA,CAAS,GAEpC,EAAS,IAAA,CAAK,KAAd,KACK,CACL,IAAI,EAkBJ,GAhBI,AAAkB,UAAlB,OAAO,EAET,CAAA,EAAO,SAAS,aAAA,CAAc,EAA9B,IAGM,AAAW,SAAX,EACF,EAAS,EAET,QAAQ,IAAA,CAAK,0BAA2B,IAGnC,aAAkB,aAAe,GAAQ,UAElD,CAAA,EAAO,CAFT,EAKI,EAAM,CACR,GAAI,IAAA,CAAK,OAAA,CAAQ,OAAA,GAAY,OAAQ,CAEnC,IAAM,EAAc,IAAA,CAAK,WAAA,CAAY,qBAAA,GACrC,GAAU,IAAA,CAAK,YAAA,CAAe,EAAY,IAAA,CAAO,EAAY,GAA7D,AACF,CAEA,IAAM,EAAO,EAAK,qBAAA,GAElB,EACG,AAAA,CAAA,IAAA,CAAK,YAAA,CAAe,EAAK,IAAA,CAAO,EAAK,GAAA,AAAA,EAAO,IAAA,CAAK,cADpD,AAEF,CACF,CAEA,GAAI,AAAkB,UAAlB,OAAO,GAKX,GAHA,GAAU,EACV,EAAS,KAAK,KAAA,CAAM,GAEhB,IAAA,CAAK,OAAA,CAAQ,QAAA,CACf,CAAA,GAAI,EAAc,CAChB,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,MAA/C,CAEA,IAAM,EAAW,EAAS,IAAA,CAAK,cAA/B,AAEI,CAAA,EAAW,IAAA,CAAK,KAAA,CAAQ,EAC1B,GAAkB,IAAA,CAAK,KAAvB,CACS,EAAW,CAAC,IAAA,CAAK,KAAA,CAAQ,GAClC,CAAA,GAAkB,IAAA,CAAK,KAAvB,AAAuB,CAE3B,CAAA,MAEA,EAAS,EAAM,EAAG,EAAQ,IAAA,CAAK,KAAK,EAGtC,GAAI,IAAW,IAAA,CAAK,YAAA,CAAc,CAChC,IAAU,IAAI,EACd,IAAa,IAAI,EACjB,MACF,CAIA,GAFA,IAAA,CAAK,QAAA,CAAW,GAAY,CAAC,EAEzB,EAAW,CACb,IAAA,CAAK,cAAA,CAAiB,IAAA,CAAK,YAAA,CAAe,EAC1C,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAM,EAC1B,IAAA,CAAK,KAAA,GACL,IAAA,CAAK,4BAAA,GACL,IAAA,CAAK,IAAA,GACL,IAAa,IAAI,EACjB,IAAA,CAAK,QAAA,CAAW,CAAC,EAEjB,sBAAsB,KACpB,IAAA,CAAK,sBAAA,EACP,GACA,MACF,CAEI,AAAC,GACH,CAAA,IAAA,CAAK,YAAA,CAAe,CADtB,EAKI,AAAoB,UAApB,OAAO,GAAyB,AAAkB,YAAlB,OAAO,EACzC,EAAS,EACA,AAAkB,YAAlB,OAAO,GAAyB,AAAoB,UAApB,OAAO,GAChD,CAAA,EAAW,CAAA,EAGb,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,IAAA,CAAK,cAAA,CAAgB,EAAQ,CAC/C,SAAA,EACA,OAAA,EACA,KAAAA,EACA,QAAS,KAEH,GAAM,CAAA,IAAA,CAAK,QAAA,CAAW,CAAA,CAA1B,EACA,IAAA,CAAK,WAAA,CAAc,SACnB,IAAU,IAAI,CAChB,EACA,SAAU,CAAC,EAAe,KACxB,IAAA,CAAK,WAAA,CAAc,SAGnB,IAAA,CAAK,YAAA,CAAe,IAAA,CAAK,QAAzB,CACA,IAAA,CAAK,QAAA,CAAW,EAAQ,IAAA,CAAK,cAA7B,CACA,IAAA,CAAK,SAAA,CAAY,KAAK,IAAA,CAAK,IAAA,CAAK,QAAQ,EAExC,IAAA,CAAK,cAAA,CAAiB,EACtB,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAM,EAEtB,GAEF,CAAA,IAAA,CAAK,YAAA,CAAe,CAFtB,EAKI,AAAC,GAAW,IAAA,CAAK,IAAA,GAEjB,IACF,IAAA,CAAK,KAAA,GACL,IAAA,CAAK,IAAA,GACL,IAAa,IAAI,EACjB,IAAA,CAAK,QAAA,CAAW,CAAC,EAEjB,sBAAsB,KACpB,IAAA,CAAK,sBAAA,EACP,GAGA,IAAA,CAAK,4BAAA,GAET,CACF,IACF,CAEQ,8BAA+B,CACrC,IAAA,CAAK,6BAAA,CAAgC,CAAA,EAErC,sBAAsB,KACpB,IAAA,CAAK,6BAAA,CAAgC,CAAA,CACvC,EACF,CAEQ,kBACN,CAAA,CACA,CAAA,OAAE,CAAA,CAAA,OAAQ,CAAA,CAAO,CACjB,CACA,IAKI,EACF,EACA,EACA,EACA,EACA,EACA,EACA,EAgEE,EAqBA,EAAQ,EAAW,EAAO,EAAa,EAjGrC,EAAO,KAAK,GAAA,GAGZ,EAAS,EAAK,MAAA,GAAW,CAAC,EAW1B,EAAqB,IAAA,CAAK,OAAA,CAAQ,kBAAxC,CAEA,GAAI,EAAQ,CAAA,EAAM,IAAA,EAAQ,CAAA,EAAK,IAAM,CACnC,EAAM,IAAA,CAAO,KAAK,GAAA,GAElB,IAAM,EAAgB,OAAO,gBAAA,CAAiB,EAC9C,CAAA,EAAM,aAAA,CAAgB,EAEtB,IAAM,EAAkB,EAAc,SAAtC,CACM,EAAkB,EAAc,SAAtC,CAOA,GALA,EAAe,CAAC,OAAQ,UAAW,SAAQ,CAAE,QAAA,CAAS,GACtD,EAAe,CAAC,OAAQ,UAAW,SAAQ,CAAE,QAAA,CAAS,GACtD,EAAM,YAAA,CAAe,EACrB,EAAM,YAAA,CAAe,EAEjB,CAAC,GAAgB,CAAC,GAClB,AAAuB,aAAvB,GAAqC,CAAC,GACtC,AAAuB,eAAvB,GAAuC,CAAC,EAFR,MAAO,CAAA,EAI3C,EAAc,EAAK,WAAnB,CACA,EAAe,EAAK,YAApB,CAEA,EAAc,EAAK,WAAnB,CACA,EAAe,EAAK,YAApB,CAEA,EAAgB,EAAc,EAC9B,EAAgB,EAAe,EAE/B,EAAM,aAAA,CAAgB,EACtB,EAAM,aAAA,CAAgB,EACtB,EAAM,WAAA,CAAc,EACpB,EAAM,YAAA,CAAe,EACrB,EAAM,WAAA,CAAc,EACpB,EAAM,YAAA,CAAe,CACvB,MACE,EAAgB,EAAM,aAAtB,CACA,EAAgB,EAAM,aAAtB,CACA,EAAe,EAAM,YAArB,CACA,EAAe,EAAM,YAArB,CACA,EAAc,EAAM,WAApB,CACA,EAAe,EAAM,YAArB,CACA,EAAc,EAAM,WAApB,CACA,EAAe,EAAM,YAArB,CAGF,GACG,CAAC,GAAgB,CAAC,GAClB,CAAC,GAAiB,CAAC,GAKlB,AAAuB,aAAvB,GAAsC,CAAA,CAAC,GAAgB,CAAC,CAAA,GAI1D,AAAuB,eAAvB,GACC,CAAA,CAAC,GAAgB,CAAC,CAAA,IAMjB,AAAuB,eAAvB,EACF,EAAc,IACL,AAAuB,aAAvB,EACT,EAAc,KAKV,AAH4B,IAAX,GAGD,GAAgB,GAClC,CAAA,EAAc,GADhB,EAII,AAN4B,IAAX,GAMD,GAAgB,GAClC,CAAA,EAAc,GADhB,GAKE,CAAC,GA/BH,MAAO,CAAA,EAmCT,GAAI,AAAgB,MAAhB,EACF,EAAS,EAAK,UAAd,CACA,EAAY,EAAc,EAC1B,EAAQ,EAER,EAAc,EACd,EAAe,OACjB,GAAW,AAAgB,MAAhB,EAQT,MAAO,CAAA,EAPP,EAAS,EAAK,SAAd,CACA,EAAY,EAAe,EAC3B,EAAQ,EAER,EAAc,EACd,EAAe,EAOjB,MAAO,AAFY,CAAA,EAAQ,EAAI,EAAS,EAAY,EAAS,CAAA,GAExC,GAAe,CACtC,CAKA,IAAI,aAAc,CAChB,OACE,IAAA,CAAK,OAAA,CAAQ,OAAA,GAAY,OACrB,SAAS,eAAA,CACT,IAAA,CAAK,OAAA,CAAQ,OAHnB,AAKF,CAKA,IAAI,OAAQ,QACV,AAAI,IAAA,CAAK,OAAA,CAAQ,eAAA,CACX,IAAA,CAAK,YAAA,CACA,IAAA,CAAK,WAAA,CAAY,WAAA,CAAc,IAAA,CAAK,WAAA,CAAY,WAAvD,CAEO,IAAA,CAAK,WAAA,CAAY,YAAA,CAAe,IAAA,CAAK,WAAA,CAAY,YAAxD,CAGK,IAAA,CAAK,UAAA,CAAW,KAAA,CAAM,IAAA,CAAK,YAAA,CAAe,IAAM,IAAvD,AAEJ,CAKA,IAAI,cAAe,CACjB,MAAO,AAA6B,eAA7B,IAAA,CAAK,OAAA,CAAQ,WAAA,AACtB,CAKA,IAAI,cAAe,CAGjB,IAAM,EAAU,IAAA,CAAK,OAAA,CAAQ,OAA7B,CAEA,OAAO,IAAA,CAAK,YAAA,CACP,EAAmB,OAAA,EAAY,EAAwB,UAAA,CACvD,EAAmB,OAAA,EAAY,EAAwB,SAF5D,AAGF,CAKA,IAAI,QAAS,KNt7BmB,EMu7B9B,OAAO,IAAA,CAAK,OAAA,CAAQ,QAAA,CNt7Bb,CAAA,AMu7BI,IAAA,CAAK,cAAA,ENx7Bc,EMw7BE,IAAA,CAAK,KAAK,ENv7B1B,CAAA,EAAK,EMw7BjB,IAAA,CAAK,cAFT,AAGF,CAKA,IAAI,UAAW,CAEb,OAAO,AAAe,IAAf,IAAA,CAAK,KAAA,CAAc,EAAI,IAAA,CAAK,MAAA,CAAS,IAAA,CAAK,KAAjD,AACF,CAKA,IAAI,aAAc,CAChB,OAAO,IAAA,CAAK,YAAZ,AACF,CAEA,IAAY,YAAY,CAAA,CAAkB,CACpC,IAAA,CAAK,YAAA,GAAiB,IACxB,IAAA,CAAK,YAAA,CAAe,EACpB,IAAA,CAAK,eAAA,GAET,CAKA,IAAI,WAAY,CACd,OAAO,IAAA,CAAK,UAAZ,AACF,CAEA,IAAY,UAAU,CAAA,CAAgB,CAChC,IAAA,CAAK,UAAA,GAAe,IACtB,IAAA,CAAK,UAAA,CAAa,EAClB,IAAA,CAAK,eAAA,GAET,CAKA,IAAI,UAAW,CACb,OAAO,IAAA,CAAK,SAAZ,AACF,CAEA,IAAY,SAAS,CAAA,CAAgB,CAC/B,IAAA,CAAK,SAAA,GAAc,IACrB,IAAA,CAAK,SAAA,CAAY,EACjB,IAAA,CAAK,eAAA,GAET,CAKA,IAAI,UAAW,CACb,MAAO,AAAqB,WAArB,IAAA,CAAK,WAAA,AACd,CAKA,IAAI,WAAY,CACd,IAAI,EAAY,QAMhB,OALI,IAAA,CAAK,OAAA,CAAQ,UAAA,EAAY,CAAA,GAAa,mBAA1C,EACI,IAAA,CAAK,SAAA,EAAW,CAAA,GAAa,gBAAjC,EACI,IAAA,CAAK,QAAA,EAAU,CAAA,GAAa,eAAhC,EACI,IAAA,CAAK,WAAA,EAAa,CAAA,GAAa,kBAAnC,EACI,AAAqB,WAArB,IAAA,CAAK,WAAA,EAA0B,CAAA,GAAa,eAAhD,EACO,CACT,CAEQ,iBAAkB,CACxB,IAAA,CAAK,gBAAA,GAEL,IAAA,CAAK,WAAA,CAAY,SAAA,CACf,CAAA,EAAG,IAAA,CAAK,WAAA,CAAY,SAAS,CAAA,CAAA,EAAI,IAAA,CAAK,SAAS,CAAA,CAAA,CAAG,IAAA,EACtD,CAEQ,kBAAmB,CACzB,IAAA,CAAK,WAAA,CAAY,SAAA,CAAY,IAAA,CAAK,WAAA,CAAY,SAAA,CAC3C,OAAA,CAAQ,gBAAiB,IACzB,IAAA,EACL,CACF,EbrjCqB8a,SAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,MAAAA,GAAAA,EAAAA,EAAAA,MAAAA,AAAAA,GAAAA,CAAAA,EAAAA,EAAAA,MAAAA,AAAAA,EAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,MAAAA,GAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,OAAAA,CAAAA,CAAAA,SAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,IAAAA,EAAAA,IAAAA,OAAAA,QAAAA,CAAAA,CAAAA,OAAAA,QAAAA,CAAAA,EAAAA,CAAAA,CAAAA,aAAAA,CAAAA,GAAAA,EAAAA,MAAAA,AAAAA,CAAAA,EAAAA,EAAAA,IAAAA,CAAAA,EAAAA,EAAAA,IAAAA,CAAAA,IAAAA,CAAAA,GAAAA,GAAAA,MAAAA,OAAAA,CAAAA,IAAAA,CAAAA,EAAAA,SAAAA,CAAAA,EAAAA,GAAAA,EAAAA,CAAAA,GAAAA,UAAAA,OAAAA,EAAAA,OAAAA,EAAAA,EAAAA,KAAAA,GAAAA,IAAAA,EAAAA,AAAAA,CAAAA,CAAAA,CAAAA,EAAAA,QAAAA,CAAAA,IAAAA,CAAAA,GAAAA,KAAAA,CAAAA,EAAAA,IAAAA,MAAAA,WAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,EAAAA,EAAAA,WAAAA,CAAAA,IAAAA,AAAAA,EAAAA,QAAAA,GAAAA,QAAAA,EAAAA,MAAAA,IAAAA,CAAAA,GAAAA,cAAAA,GAAAA,2CAAAA,IAAAA,CAAAA,GAAAA,EAAAA,EAAAA,KAAAA,GAAAA,KAAAA,CAAAA,CAAAA,EAAAA,EAAAA,GAAAA,GAAAA,GAAAA,UAAAA,OAAAA,EAAAA,MAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,EAAAA,IAAAA,EAAAA,EAAAA,OAAAA,WAAAA,OAAAA,GAAAA,EAAAA,MAAAA,CAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,KAAAA,CAAAA,EAAAA,MAAAA,CAAAA,CAAAA,IAAAA,AAAAA,CAAAA,CAAAA,CAAAA,MAAAA,AAAAA,UAAAA,wIAAAA,CAAAA,SAAAA,IAAAA,MAAAA,CAAAA,EAAAA,OAAAA,MAAAA,CAAAA,OAAAA,MAAAA,CAAAA,IAAAA,GAAAA,SAAAA,CAAAA,EAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,UAAAA,MAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,SAAAA,CAAAA,EAAAA,CAAAA,IAAAA,IAAAA,KAAAA,EAAAA,AAAAA,CAAAA,CAAAA,CAAAA,EAAAA,cAAAA,CAAAA,IAAAA,CAAAA,EAAAA,IAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA,CAAAA,EAAAA,AAAAA,CAAAA,CAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA,KAAAA,UAAAA,CAAAA,IAAAA,EAOjB,WAAA,SAAAA,EAAAC,CAAAA,EAKa,IAJTzJ,EAAcyJ,EAAdzJ,cAAAA,CAAc0J,EAAAD,EACdxJ,UAAAA,CAAkC0J,EAAAF,EAClCvJ,IAAAA,CACAE,EAAKqJ,EAALrJ,KAAAA,AAVGJ,CAAAA,IAAAA,CAAAA,cAAAA,CAAAA,KACCC,EAAAA,IAAAA,CAAAA,UAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,IAAAA,CAAAA,KACAE,EAAAA,IAAAA,CAAAA,KAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,QAAAA,CAAAA,KASJ,EAAAuJ,IAAAA,CAAK5J,cAAAA,CAAiBA,EACtB4J,IAAAA,CAAK3J,UAAAA,CANLA,KAAU,IAAAyJ,EAAG,sBAAqBA,EAOlCE,IAAAA,CAAK1J,IAAAA,CANLA,KAAO,IAAHyJ,EAAG,KAAIA,EAOXC,IAAAA,CAAKxJ,KAAAA,CAAQA,EAGbwJ,IAAAA,CAAKtJ,KAAAA,EACT,CAAC,IAAAuJ,EAAAL,EAAAjJ,SAAAA,CA6GA,OA7GAsJ,EAOOvJ,KAAAA,CAAA,WAAK,IAAAwJ,EAAAF,IAAAA,AAyBTA,CAAAA,IAAAA,CAAKvJ,QAAAA,CAAW,IAAIG,qBAjBA,SAACuJ,CAAAA,EACjBA,EAAQtJ,OAAAA,CAAQ,SAACuJ,CAAAA,EACb,IAAMC,EACFH,EAAK9J,cAAAA,CAAetG,IAAAA,CAChB,SAACwQ,CAAAA,EAAS,OAAAA,EAAKxJ,GAAAA,GAAQsJ,EAAMpQ,MAAM,AAAA,EAGvCoQ,CAAAA,EAAMrJ,cAAAA,CACNsJ,CAAAA,GAAgBA,CAAAA,EAAYrJ,oBAAAA,CAAAA,CAAuB,CAAA,EACnDkJ,EAAKjJ,UAAAA,CAAWmJ,EAAAA,EACTC,GAAeA,EAAYrJ,oBAAAA,EAClCkJ,EAAKhJ,aAAAA,CAAckJ,EAE3B,EACJ,EApBwB,CACpB9J,KAAM0J,IAAAA,CAAK1J,IAAAA,CACXD,WAAY2J,IAAAA,CAAK3J,UAAAA,AAAAA,GAwBrB,IAAA,IAA+CkK,EAA/CC,EAAAC,EAA4BT,IAAAA,CAAK5J,cAAAA,EAAAA,CAAAA,AAAcmK,CAAAA,EAAAC,GAAAA,EAAA5K,IAAAA,EAE3CoK,IAAAA,CAAK3Y,OAAAA,CAFekZ,EAAA7b,KAAAA,CACiBoS,GAAAA,CAG7C,EAACmJ,EAKMtY,OAAAA,CAAA,WACHqY,IAAAA,CAAKvJ,QAAAA,CAAS7O,UAAAA,EAClB,EAACqY,EAOM5Y,OAAAA,CAAA,SAAQqZ,CAAAA,EACNA,GAILV,IAAAA,CAAKvJ,QAAAA,CAASpP,OAAAA,CAAQqZ,EAC1B,EAACT,EAOM9I,SAAAA,CAAA,SAAUuJ,CAAAA,EACRA,GAILV,IAAAA,CAAKvJ,QAAAA,CAASU,SAAAA,CAAUuJ,EAC5B,EAACT,EASOhJ,UAAAA,CAAA,SAAWmJ,CAAAA,EACf,IAAMO,EAAgBX,IAAAA,CAAK5J,cAAAA,CAAetG,IAAAA,CACtC,SAAC6Q,CAAAA,EAAa,OAAKA,EAAc7J,GAAAA,GAAQsJ,EAAMpQ,MAAM,AAAA,EAGzDgQ,CAAAA,IAAAA,CAAKxJ,KAAAA,EAASmK,CAAAA,MAAAA,GAAAA,EAAevJ,kBAAAA,EAAAA,EAAAA,AAC5B4I,IAAAA,CAAKxJ,KAAAA,EAASmK,MAAAA,GAAAA,EAAetJ,SAAAA,EAClC,EAAC4I,EASO/I,aAAAA,CAAA,SAAckJ,CAAAA,EAClB,IAAMO,EAAgBX,IAAAA,CAAK5J,cAAAA,CAAetG,IAAAA,CACtC,SAAC6Q,CAAAA,EAAkB,OAAAA,EAAc7J,GAAAA,GAAQsJ,EAAMpQ,MAAM,AAAA,EAGzDgQ,CAAAA,IAAAA,CAAKxJ,KAAAA,EAAsB,CAAA,MAAbmK,GAAAA,EAAerJ,mBAAAA,EAAAA,EAAAA,AAC5B0I,IAAAA,CAAKxJ,KAAAA,EAAsB,MAAbmK,GAAAA,EAAepJ,YAAAA,GAGzBoJ,MAAAA,GAAAA,EAAenJ,UAAAA,CAAWC,YAAAA,EAAiBuI,IAAAA,CAAKxJ,KAAAA,EACjDwJ,IAAAA,CAAK7I,SAAAA,CAAUiJ,EAAMpQ,MAAAA,CAE7B,EAAC4P,CAAA,ICzFW,SAAAqB,EAAcC,CAAAA,CAAiBlR,CAAAA,EAC3C,OAAOkR,EAAMvJ,MAAAA,CAAO,SAACwJ,CAAAA,CAAMC,CAAAA,EACvB,OAAO7c,KAAKiN,GAAAA,CAAI4P,EAAOpR,GAAUzL,KAAKiN,GAAAA,CAAI2P,EAAOnR,GAAUoR,EAAOD,CACtE,EACJ,CCnCA,IACME,EAAmB,aAEJC,EA2CjB,WAAA,SAAAA,EAAAzB,CAAAA,EAQwB0B,IAAAA,EAAAC,EAAAC,EAAAC,EAAAC,EAAAzB,EAPpBF,IAAAA,CAAAlJ,EAAG+I,EAAH/I,GAAAA,CACAmB,EAAE4H,EAAF5H,EAAAA,CACAE,EAAwB0H,EAAxB1H,wBAAAA,CACAE,EAA0BwH,EAA1BxH,0BAAAA,CACAE,EAAOsH,EAAPtH,OAAAA,CACAC,EAAiBqH,EAAjBrH,iBAAAA,CACAE,EAAamH,EAAbnH,aAAAA,AAjDG5B,CAAAA,IAAAA,CAAAA,GAAAA,CAAAA,KACAmB,EAAAA,IAAAA,CAAAA,EAAAA,CAAAA,KACAM,EAAAA,IAAAA,CAAAA,OAAAA,CAAAA,KACAf,EAAAA,IAAAA,CAAAA,UAAAA,CAAAA,KACAgB,EAAAA,IAAAA,CAAAA,iBAAAA,CAAAA,KACAxB,EAAAA,IAAAA,CAAAA,oBAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CAEC2B,YAAAA,CAAAA,KAAY,EAAAqH,IAAAA,CACZpH,OAAAA,CAAAA,KAAO,EAAAoH,IAAAA,CACPnH,aAAAA,CAAAA,KAAa,EAAAmH,IAAAA,CACblH,cAAAA,CAAAA,KAAc,EAAAkH,IAAAA,CACdtL,QAAAA,CAAAA,KAAQ,EAAAsL,IAAAA,CACRjH,YAAAA,CAAAA,KAAY,EAAAiH,IAAAA,CACZhH,QAAAA,CAAAA,KAAQ,EAAAgH,IAAAA,CACR/G,aAAAA,CAAAA,KAAa,EAAA+G,IAAAA,CACb9G,QAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAEAhB,EAAAA,IAAAA,CAAAA,wBAAAA,CAAAA,KACAE,EAAAA,IAAAA,CAAAA,0BAAAA,CAAAA,KACAK,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAGAU,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,eAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,cAAAA,CAAAA,KAGSC,EAAAA,IAAAA,CAAAA,qBAAAA,CAAwH,CACrIxH,MAAS,SAACwI,CAAAA,CAAaqH,CAAAA,CAAOC,CAAAA,EAAa,OAAAtH,EAAcqH,EAAQC,CAAQ,EACzErI,OAAU,SAACe,CAAAA,CAAaqH,CAAAA,CAAOC,CAAAA,CAAUC,CAAAA,EAAAA,OAASvH,EAAcqH,EAAQC,EAAkB,GAAPC,CAAU,EAC7FrI,IAAO,SAACc,CAAAA,CAAaqH,CAAAA,CAAOC,CAAAA,CAAUC,CAAAA,EAAI,OAAKvH,EAAcqH,EAAQC,EAAWC,CAAI,EACpFpI,KAAQ,WAAM,OAAA,CAAC,CAAA,EAIFC,IAAAA,CAAAA,mBAAAA,CAAuG,CACpH5H,MAAS,SAACwI,CAAAA,CAAasH,CAAAA,EAAa,OAAAtH,EAAcsH,CAAQ,EAC1DrI,OAAU,SAACe,CAAAA,CAAasH,CAAAA,CAAUC,CAAAA,EAAS,OAAAvH,EAAcsH,EAAkB,GAAPC,CAAU,EAC9ErI,IAAO,SAACc,CAAAA,CAAasH,CAAAA,CAAUC,CAAAA,EAAI,OAAKvH,EAAcsH,EAAWC,CAAI,CAAA,EAarE9B,IAAAA,CAAKlJ,GAAAA,CAAMA,EAEXkJ,IAAAA,CAAK/H,EAAAA,CAAKA,EAEV+H,IAAAA,CAAKzH,OAAAA,CAAUA,EAEfyH,IAAAA,CAAKxH,iBAAAA,CAAoBA,EAEzBwH,IAAAA,CAAKtH,aAAAA,CAAgBA,EAErBsH,IAAAA,CAAK7H,wBAAAA,CAA2BA,EAChC6H,IAAAA,CAAK3H,0BAAAA,CAA6BA,EAGlC2H,IAAAA,CAAKxI,UAAAA,CAAa,CACdoC,YAA4C2H,MAAjCA,CAAAA,EAAEvB,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAqB,WAAA,AAAA,EAAC0H,EAvEnC,YAwETzH,aAA8C0H,MAAlCA,CAAAA,EAAExB,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAsB,YAAA,AAAA,EAAC2H,EAAI,MAClDzH,eAAkD0H,MAApCA,CAAAA,EAAEzB,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAwB,cAAA,AAAA,EAAC4H,EAAI,YACtDzH,kBAAAA,KAA6D+H,IAA1C/B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAA2B,iBAAA,CACvDI,oBAC2CyH,MADxBA,CAAAA,EACf1B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAA6B,mBAAA,AAAA,EAAC6H,EAAI,KAC/CxH,YAAAA,KACwC6H,IAApC/B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAqB,WAAA,CACxBM,WAAW6F,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAqB,WAAA,EACzC,KACVpC,aAAAA,KAAmDsK,IAArC/B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAsB,YAAA,CAC7CO,WAA0C,MAAhCuH,CAAAA,EAAE3B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAoB,UAAA,AAAA,EAAC8H,EAAI,KAC9CtH,iBAAAA,KAA2D0H,IAAzC/B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAA0B,gBAAA,CACrDS,uBAAAA,KACmDyH,IAA/C/B,IAAAA,CAAKlJ,GAAAA,CAAI+C,OAAAA,CAAgC,sBAAA,AAAA,EAIjDmG,IAAAA,CAAKrH,YAAAA,CAAe,CAChB5G,MAAO,EACP0H,IAAK,CAAA,EAITuG,IAAAA,CAAKpH,OAAAA,CAAU,CACX2B,YAAa,EACbC,UAAW,EACXC,IAAK,CAAA,CAAA,EAITuF,IAAAA,CAAKnH,aAAAA,CAAgBmH,IAAAA,CAAKtH,aAAAA,CAAcxJ,MAAAA,CAGxC8Q,IAAAA,CAAKlH,cAAAA,CAAiB,EAGtBkH,IAAAA,CAAKtL,QAAAA,CAAW,EAChBsL,IAAAA,CAAKjH,YAAAA,CAAe,KAGpBiH,IAAAA,CAAKhH,QAAAA,CAAAA,CAAW,EAChBgH,IAAAA,CAAK/G,aAAAA,CAAAA,CAAgB,EACrB+G,IAAAA,CAAKhJ,oBAAAA,CAAAA,CAAuB,EAC5BgJ,IAAAA,CAAK9G,QAAAA,CAAAA,CAAW,EAChB8G,IAAAA,CAAK7G,aAAAA,CAAAA,CAAgB,EAGrB6G,IAAAA,CAAK5G,aAAAA,CAA2C,aAA3B4G,IAAAA,CAAKxH,iBAAAA,CACpB,WAAA,OAAM0H,EAAKxH,aAAAA,CAAc/M,UAAAA,CAAWnE,MAAM,AAAA,EAC1C,WAAM,OAAA0Y,EAAKxH,aAAAA,CAAc/M,UAAAA,CAAWpE,KAAK,AAAA,EAE/CyY,IAAAA,CAAK3G,eAAAA,CAA6C,aAA3B2G,IAAAA,CAAKxH,iBAAAA,CACtB,SAACiC,CAAAA,EAAY,OAAKA,EAAInL,GAAG,AAAA,EACzB,SAACmL,CAAAA,EAAY,OAAKA,EAAIrL,IAAI,AAAA,EAEhC4Q,IAAAA,CAAK1G,cAAAA,CAA4C,aAA3B0G,IAAAA,CAAKxH,iBAAAA,CACrB,SAACiC,CAAAA,EAAiB,OAAAA,EAAIjT,MAAM,AAAA,EAC5B,SAACiT,CAAAA,EAAY,OAAKA,EAAIlT,KAAK,AAAA,EAGjCyY,IAAAA,CAAKtJ,KAAAA,EACT,CAAC,IAAAuJ,EAAAqB,EAAA3K,SAAAA,CAkXA2K,OAlXArB,EAOOvJ,KAAAA,CAAA,WACCsJ,IAAAA,CAAKzH,OAAAA,EAKVyH,IAAAA,CAAKtF,OAAAA,EACT,EAACuF,EAKMtF,QAAAA,CAAA,SAAQqH,CAAAA,EACXhC,IAAAA,CAAKnH,aAAAA,CADsBmJ,EAAbnJ,aAAAA,CAEdmH,IAAAA,CAAKtF,OAAAA,EACT,EAACuF,EAKMrF,QAAAA,CAAA,SAAQqH,CAAAA,EAAG,IAAApJ,EAAaoJ,EAAbpJ,aAAAA,CAAegC,EAAMoH,EAANpH,MAAAA,CACvB+G,EAAQ5B,IAAAA,CAAK5G,aAAAA,GAKnB,GAJA4G,IAAAA,CAAKnH,aAAAA,CAAgBA,EACrBmH,IAAAA,CAAKlF,gBAAAA,GAIDkF,IAAAA,CAAKxI,UAAAA,CAAW0C,WAAAA,EAAAA,CACfa,MAAMiF,IAAAA,CAAKxI,UAAAA,CAAW0C,WAAAA,EAGvB,GAAK8F,IAAAA,CAAKxI,UAAAA,CAAW8C,sBAAAA,EAA2BO,EAOzC,CAEH,GAAImF,IAAAA,CAAK9G,QAAAA,CAAU,CACf,IAAMxE,EAAWnQ,KAAKD,GAAAA,CAAI,EAAG0b,IAAAA,CAAKtL,QAAAA,CAClCsL,CAAAA,IAAAA,CAAKlH,cAAAA,CACDpE,CAAAA,CAAAA,EAAWkN,EAAQ5B,IAAAA,CAAKxI,UAAAA,CAAW0C,WAAAA,CAAAA,CADvC8F,CAEJ,KAAO,CACH,IAAMtL,EDlLfqM,ACkLsC,GDlL1Brc,CAAAA,AAAAA,CAAAA,ACkLoCsb,IAAAA,CAAKtL,QAAAA,CAAlB,CDlLfmM,EAFXC,EACCE,GAC0C,CAAA,CCmL3ChB,CAAAA,IAAAA,CAAKlH,cAAAA,CACDpE,CAAAA,CAAAA,EAAWkN,EAAQ5B,IAAAA,CAAKxI,UAAAA,CAAW0C,WAAAA,CAAAA,CADvC8F,CAEJ,CAEAA,IAAAA,CAAKlJ,GAAAA,CAAI9E,KAAAA,CAAMgJ,SAAAA,CACgB,aAA3BgF,IAAAA,CAAKxH,iBAAAA,CACmB,kBAAAwH,IAAAA,CAAKlH,cAAAA,CACR,SAAA,eAAAkH,IAAAA,CAAKlH,cAAAA,CAAc,WAChD,MAtBQkH,IAAAA,CAAKlH,cAAAA,EACLkH,CAAAA,IAAAA,CAAKlJ,GAAAA,CAAI9E,KAAAA,CAAMgJ,SAAAA,CACnB,sBAAA,EACAgF,IAAAA,CAAKlH,cAAAA,CAAiB,CAqBlC,EAACmH,EAKM5I,SAAAA,CAAA,WACH,GAAA,CAAI2I,IAAAA,CAAKhH,QAAAA,CAAT,CAIAgH,IAAAA,CAAKhH,QAAAA,CAAAA,CAAW,EAChBgH,IAAAA,CAAKlJ,GAAAA,CAAImE,SAAAA,CAAUC,GAAAA,CAAI8E,IAAAA,CAAKxI,UAAAA,CAAWoC,WAAAA,EAEvC,IACMjV,EAAOqb,IAAAA,CAAK7E,kBAAAA,EAClB6E,CAAAA,IAAAA,CAAKxI,UAAAA,CAAW4C,UAAAA,EAAc4F,IAAAA,CAAK5E,aAAAA,CAFvB,QAE0CzW,EAPtD,CAQJ,EAACsb,EAKM1I,YAAAA,CAAA,WACH,GAAMyI,IAAAA,CAAKhH,QAAAA,EAAYgH,IAAAA,CAAKxI,UAAAA,CAAWC,YAAAA,CAAvC,CAIAuI,IAAAA,CAAKhH,QAAAA,CAAAA,CAAW,EAChBgH,IAAAA,CAAKlJ,GAAAA,CAAImE,SAAAA,CAAUI,MAAAA,CAAO2E,IAAAA,CAAKxI,UAAAA,CAAWoC,WAAAA,EAE1C,IACMjV,EAAOqb,IAAAA,CAAK7E,kBAAAA,EAClB6E,CAAAA,IAAAA,CAAKxI,UAAAA,CAAW4C,UAAAA,EAAc4F,IAAAA,CAAK5E,aAAAA,CAFvB,QAE0CzW,EAPtD,CAQJ,EAACsb,EAMM7I,kBAAAA,CAAA,WACC4I,IAAAA,CAAK/G,aAAAA,EAIT+G,CAAAA,IAAAA,CAAK/G,aAAAA,CAAAA,CAAgB,EACrB+G,IAAAA,CAAK7H,wBAAAA,CAAyB6H,IAAAA,CAAAA,CAClC,EAACC,EAMM3I,mBAAAA,CAAA,WACE0I,IAAAA,CAAK/G,aAAAA,EAIV+G,CAAAA,IAAAA,CAAK/G,aAAAA,CAAAA,CAAgB,EACrB+G,IAAAA,CAAK3H,0BAAAA,CAA2B2H,IAAAA,EAGV,OAAtBA,IAAAA,CAAKjH,YAAAA,EACDiH,IAAAA,CAAKlF,gBAAAA,CAAiBmG,EAAc,CAAC,EAAG,EAAA,CAAIjB,IAAAA,CAAKjH,YAAAA,EAAAA,CACzD,EAACkH,EAOOvF,OAAAA,CAAA,WACJsF,IAAAA,CAAKpH,OAAAA,CAAQ6B,GAAAA,CAAMuF,IAAAA,CAAKlJ,GAAAA,CAAIjE,qBAAAA,GAC5BmN,IAAAA,CAAK1E,eAAAA,GACL0E,IAAAA,CAAKzE,oBAAAA,GAGDyE,IAAAA,CAAK7G,aAAAA,EACL6G,CAAAA,IAAAA,CAAK7G,aAAAA,CAAAA,CAAgB,EAEjB6G,IAAAA,CAAK9G,QAAAA,EACL8G,IAAAA,CAAK3I,SAAAA,EAAAA,CAGjB,EAAC4I,EAOO3E,eAAAA,CAAA,WACJ,IAAMsG,EAAQ5B,IAAAA,CAAK5G,aAAAA,GACb8I,EAAelC,IAAAA,CAAK3G,eAAAA,CAAgB2G,IAAAA,CAAKpH,OAAAA,CAAQ6B,GAAAA,EACjD0H,EAAcnC,IAAAA,CAAK1G,cAAAA,CAAe0G,IAAAA,CAAKpH,OAAAA,CAAQ6B,GAAAA,CAErDuF,CAAAA,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CACTyF,IAAAA,CAAKnH,aAAAA,CAAgBqJ,EAAelC,IAAAA,CAAKlH,cAAAA,CAC7CkH,IAAAA,CAAKpH,OAAAA,CAAQ4B,SAAAA,CAAYwF,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAc4H,EAMhDnC,IAAAA,CAAK9G,QAAAA,CAHL8G,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAcqH,GAAAA,CAC1B5B,IAAAA,CAAKxI,UAAAA,CAAW6C,gBAMzB,AAAA,EAAC4F,EAQO1E,oBAAAA,CAAA,WAAoB6G,IAAAA,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAClBf,EAAQ5B,IAAAA,CAAK5G,aAAAA,GACb+I,EAAcnC,IAAAA,CAAK1G,cAAAA,CAAe0G,IAAAA,CAAKpH,OAAAA,CAAQ6B,GAAAA,EAG/CtI,EAAS6N,IAAAA,CAAKxI,UAAAA,CAAWsC,YAAAA,CAAa7J,KAAAA,CAAM,KAC5CsK,EAA+B,MAApB6H,CAAAA,EAAGC,MAAHA,CAAAA,EAAGlQ,CAAAA,CAAO,EAAA,AAAA,EAAA,KAAPkQ,EAAAA,EAAWxN,IAAAA,EAAAA,EAAMuN,EAAI,IACnC5H,EAA6B,MAApB8H,CAAAA,EAAY,MAAZC,CAAAA,EAAGpQ,CAAAA,CAAO,EAAA,AAAA,EAAA,KAAE,EAAToQ,EAAW1N,IAAAA,EAAAA,EAAMyN,EAAI,IAGjCvI,EAAiBiG,IAAAA,CAAKxI,UAAAA,CAAWuC,cAAAA,CAAe9J,KAAAA,CAAM,KACxD2S,EAA+C,MAA5BJ,CAAAA,EAAoB,MAApBC,CAAAA,EAAG1I,CAAAA,CAAe,EAAA,AAAA,EAAA,KAAE,EAAjB0I,EAAmB5N,IAAAA,EAAAA,EAAM2N,EAAI,QACjDK,EAAAA,MAAiBH,CAAAA,EAAGC,MAAHA,CAAAA,EAAG5I,CAAAA,CAAe,EAAA,AAAA,EAAA,KAAf4I,EAAAA,EAAmB9N,IAAAA,EAAAA,EAAM6N,EAAI,MAGjDI,EAAgBvI,EAAY1L,QAAAA,CAAS,KACrC+S,EAAQjG,SAASpB,EAAYzF,OAAAA,CAAQ,IAAK,IAAID,IAAAA,IAAU,IACxD8G,SAASpB,GACTwI,EAAcvI,EAAU3L,QAAAA,CAAS,KACjC+S,EAAQjG,SAASnB,EAAU1F,OAAAA,CAAQ,IAAK,IAAID,IAAAA,IAAU,IACtD8G,SAASnB,EAGXwF,CAAAA,IAAAA,CAAK9G,QAAAA,EACL0J,CAAAA,EAAsB,MAAA,EAI1B,IAAMI,EAAehD,IAAAA,CAAKzG,qBAAAA,CAAsBqJ,EAAAA,AAChD5C,CAAAA,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAAQiR,EACpBA,EAAahD,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAaqH,EAAOkB,EAAeX,GAC7DnC,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAcqH,EAAQkB,EAGzC,IAAMG,EAAajD,IAAAA,CAAKrG,mBAAAA,CAAoBkJ,EAAAA,CAM5C,GALA7C,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CAAMwJ,EAClBA,EAAWjD,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAawI,EAAaZ,GAClDnC,IAAAA,CAAKpH,OAAAA,CAAQ2B,WAAAA,CAAcwI,EAAcZ,EAG3CnC,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,EAAOuG,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAC3C,OAAQ8Q,GACJ,IAAK,QASL,QACI7C,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CAAMuG,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAAQ,EAClD,KARJ,KAAK,SACDiO,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CAAMuG,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAAsB,GAAdoQ,EAClD,KACJ,KAAK,MACDnC,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CAAMuG,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAAQoQ,CAAAA,CAOlE,EAAClC,EAUOnF,gBAAAA,CAAA,SAAiBoI,CAAAA,EAErB,ID3XJrC,EACAC,EAjB4Cpc,EC2YlCgQ,EACFwO,MAAAA,EAAAA,EAAAA,CAAAA,AD5XRrC,ECiYgBb,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CDhYlC+O,ECiYgBd,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CDlZU/U,CAAAA,EAwBrCqc,AAamB,EAbPrc,CAAAA,AAAAA,CAAAA,AC2XHsb,IAAAA,CAAKnH,aAAAA,CD3XMgI,CAAAA,EAFXC,CAAAA,EAAQD,CAAAA,EACPG,GAC0C,CAAA,CC2XtCnI,EALT,CAAA,EAAA,ED7YenU,EC8Yf,EAAA,ED9YmCA,CCsZ3Csb,CAAAA,IAAAA,CAAKtL,QAAAA,CAAWA,EAEZA,IAAasL,IAAAA,CAAKjH,YAAAA,EAClBiH,CAAAA,IAAAA,CAAKjH,YAAAA,CAAerE,EAGpBsL,IAAAA,CAAKxI,UAAAA,CAAWwC,iBAAAA,EAAqBgG,IAAAA,CAAKjE,eAAAA,CAAgBrH,GAG1DsL,IAAAA,CAAKxI,UAAAA,CAAWyC,mBAAAA,EACZ+F,IAAAA,CAAKhE,uBAAAA,CAAwBtH,GAGjCA,EAAW,GAAKA,EAAW,GAAKsL,IAAAA,CAAK3I,SAAAA,GACxB,IAAb3C,GAAkBsL,IAAAA,CAAKzI,YAAAA,GACV,IAAb7C,GAAkBsL,IAAAA,CAAKzI,YAAAA,EAAAA,CAE/B,EAAC0I,EASDlE,eAAAA,CAAA,SAAgBoH,CAAAA,EAAAA,KAAAA,IAAAA,GAAAA,CAAAA,EAAkB,CAAA,EAC9BnD,IAAAA,CAAKlJ,GAAAA,CAAI9E,KAAAA,CAAME,WAAAA,CACXmP,EACA8B,EAAgB1N,QAAAA,GAExB,EAACwK,EASDjE,uBAAAA,CAAA,SAAwBmH,CAAAA,EAAAA,KAAAA,IAAAA,GAAAA,CAAAA,EAAkB,CAAA,EACtC,IAAMC,EAAkBpD,IAAAA,CAAKxI,UAAAA,CAAWyC,mBAAAA,CAExC,GAAKmJ,EAAL,CAEA,IAAMC,EAAc,IAAIpV,YAAYmV,EAAiB,CACjD7U,OAAQ,CACJyB,OAAQgQ,IAAAA,CAAKlJ,GAAAA,CACbpC,SAAUyO,CAAAA,CAAAA,GAGlBlc,OAAOoH,aAAAA,CAAcgV,EARC,CAS1B,EAACpD,EAOD9E,kBAAAA,CAAA,WACI,IAAMmI,EAA2BrC,EAC7B,CAACjB,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,CAAOiO,IAAAA,CAAKrH,YAAAA,CAAac,GAAAA,CAAAA,CAC5CuG,IAAAA,CAAKnH,aAAAA,EAET,OAAOmH,IAAAA,CAAKrH,YAAAA,CAAa5G,KAAAA,GAAUuR,EAC7B,QACA,KACV,EAACrD,EAOMtY,OAAAA,CAAA,WAECqY,IAAAA,CAAKxI,UAAAA,CAAWwC,iBAAAA,EAChBgG,IAAAA,CAAKlJ,GAAAA,CAAI9E,KAAAA,CAAMC,cAAAA,CAAeoP,GAI9BrB,IAAAA,CAAKxI,UAAAA,CAAW0C,WAAAA,EAChB8F,IAAAA,CAAKlJ,GAAAA,CAAI9E,KAAAA,CAAMC,cAAAA,CAAe,aAI9B+N,IAAAA,CAAKhH,QAAAA,EAAYgH,IAAAA,CAAKxI,UAAAA,CAAWoC,WAAAA,EACjCoG,IAAAA,CAAKlJ,GAAAA,CAAImE,SAAAA,CAAUI,MAAAA,CAAO2E,IAAAA,CAAKxI,UAAAA,CAAWoC,WAAAA,CAElD,EAACqG,EAUD7E,aAAAA,CAAA,SAAca,CAAAA,CAAatX,CAAAA,EACvB,IAAMye,EAAkBpD,IAAAA,CAAKxI,UAAAA,CAAW4C,UAAAA,CAExC,GAAKgJ,EAAL,CAGA,IAAMC,EAAc,IAAIpV,YAAYmV,EAAiB,CACjD7U,OAAQ,CACJyB,OAAQgQ,IAAAA,CAAKlJ,GAAAA,CACbmF,IAAAA,EACAtX,KAAAA,CAAAA,CAAAA,GAGRsC,OAAOoH,aAAAA,CAAcgV,EAVC,CAW1B,EAAC/B,CAAA,ICtgBCiC,EAA2B,CAC7B,eACA,iBACA,oBACA,sBACA,cAAA,CAWiBC,EAajB,WAAA,SAAAA,EAAA3D,CAAAA,EAAAA,IACI/I,EAAG+I,EAAH/I,GAAAA,CACAsF,EAAiByD,EAAjBzD,iBAAAA,CACAC,EAAawD,EAAbxD,aAAAA,CACA7D,EAAiBqH,EAAjBrH,iBAAAA,CACAE,EAAamH,EAAbnH,aAAAA,AAAAA,CAAAA,IAAAA,CAjBI4D,gBAAAA,CAAAA,KAAgB,EAAA0D,IAAAA,CAChB5D,iBAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CACAjG,cAAAA,CAAAA,KAAc,EAAA4J,IAAAA,CACdzD,uBAAAA,CAAAA,KAAuB,EAAAyD,IAAAA,CACvBxD,iBAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,sBAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CACAC,iBAAAA,CAAAA,KAAiB,EAAAsD,IAAAA,CACjBrD,aAAAA,CAAAA,KACAnE,EAAAA,IAAAA,CAAAA,iBAAAA,CAAAA,KACAE,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EASC5B,EAMLkJ,CAAAA,IAAAA,CAAK1D,gBAAAA,CAAmBxF,EAGxBkJ,IAAAA,CAAKtH,aAAAA,CAAgBA,EAGrBsH,IAAAA,CAAKxH,iBAAAA,CAAoBA,EAGzBwH,IAAAA,CAAK5D,iBAAAA,CAAoBA,MAAAA,EAAAA,EA1CL,sBA2CpB4D,IAAAA,CAAK3D,aAAAA,CAAAA,MAAgBA,EAAAA,EA1CL,sBA6ChB2D,IAAAA,CAAK5J,cAAAA,CAAiB,EAAA,CACtB4J,IAAAA,CAAKzD,uBAAAA,CAA0B,EAAA,CAC/ByD,IAAAA,CAAKxD,iBAAAA,CAAoB,EAAA,CACzBwD,IAAAA,CAAKvD,sBAAAA,CAAyB,EAAA,CAI9BuD,IAAAA,CAAKtJ,KAAAA,EAAAA,EAzBDjE,QAAQmK,KAAAA,CAAM,kDA0BtB,CAAC,IAAAqD,EAAAuD,EAAA7M,SAAAA,CAoUA,OApUAsJ,EAOOvJ,KAAAA,CAAA,WACJ,IAAM+M,EACFzD,IAAAA,CAAK1D,gBAAAA,CAAiBO,gBAAAA,CAAiB,iBAErC6G,EAAqB1D,IAAAA,CAAKlD,cAAAA,CAAe2G,GAC/CzD,IAAAA,CAAKjD,wBAAAA,CAAyB2G,GAG9B,IAAMC,EAAS3D,IAAAA,CAAKtH,aAAAA,CAAcpP,OAAAA,CAAQpD,OAAAA,GAAYe,OAChD,KACA+Y,IAAAA,CAAKtH,aAAAA,CAAcpP,OAAAA,CAAQpD,OAAAA,AAGjC8Z,CAAAA,IAAAA,CAAKtD,iBAAAA,CAAoB,IAAIkD,EAAG,CAC5BxJ,eAAAA,EAAAA,CAAc4G,MAAAA,CAAMgD,IAAAA,CAAKzD,uBAAAA,EACzBjG,KAAMqN,EACNtN,WAAY2J,IAAAA,CAAK5D,iBAAAA,CACjB5F,MAAAA,CAAO,CAAA,GAIXwJ,IAAAA,CAAKrD,aAAAA,CAAgB,IAAIiD,EAAG,CACxBxJ,eAAAA,EAAAA,CAAc4G,MAAAA,CAAMgD,IAAAA,CAAKxD,iBAAAA,EACzBlG,KAAMqN,EACNtN,WAAY2J,IAAAA,CAAK3D,aAAAA,CACjB7F,MAAAA,CAAO,CAAA,EAEf,EAACyJ,EAKMtY,OAAAA,CAAA,WACHqY,IAAAA,CAAKtD,iBAAAA,CAAkB/U,OAAAA,GACvBqY,IAAAA,CAAKrD,aAAAA,CAAchV,OAAAA,GACnBqY,IAAAA,CAAK/C,6BAAAA,EACT,EAACgD,EAKDtF,QAAAA,CAAA,SAAQqH,CAAAA,EACJ,IADO,IAC2CzB,EAD3C1H,EAAamJ,EAAbnJ,aAAAA,CACP2H,EAAAC,EAA4BT,IAAAA,CAAKxD,iBAAAA,EAAAA,CAAiB+D,AAAAA,CAAAA,EAAAC,GAAAA,EAAA5K,IAAAA,EAA1B2K,EAAA7b,KAAAA,CACNiW,QAAAA,CAAS,CACnB9B,cAAAA,CAAAA,EAGZ,EAACoH,EAKDrF,QAAAA,CAAA,SAAQqH,CAAAA,EACJ,IAAA,IAAuD2B,EADhD/K,EAAaoJ,EAAbpJ,aAAAA,CAAegC,EAAMoH,EAANpH,MAAAA,CACtBgJ,EAAApD,EAA4BT,IAAAA,CAAKvD,sBAAAA,EAAAA,CAAsBmH,AAAAA,CAAAA,EAAAC,GAAAA,EAAAjO,IAAAA,EAA/BgO,EAAAlf,KAAAA,CACNkW,QAAAA,CAAS,CACnB/B,cAAAA,EACAgC,OAAAA,CAAAA,EAGZ,EAACoF,EAOD/C,oBAAAA,CAAA,SAAqB4G,CAAAA,EAAAA,IAA0B5D,EAAAF,IAAAA,CACrC+D,EACFD,EAAcjH,gBAAAA,CAAiB,iBAEnC,GAAKkH,EAAwBpb,MAAAA,CAA7B,CAKA,IAHA,IAAMqb,EAA6B,IAAI7G,IAAIlI,MAAMtQ,IAAAA,CAAKof,IAG7CE,EAAQ,EAAGA,EAAQjE,IAAAA,CAAKzD,uBAAAA,CAAwB5T,MAAAA,CAAQsb,IAAS,CACtE,IAAMtD,EAAgBX,IAAAA,CAAKzD,uBAAAA,CAAwB0H,EAAAA,AAC/CD,CAAAA,EAA2B5G,GAAAA,CAAIuD,EAAc7J,GAAAA,GAC7CkJ,CAAAA,IAAAA,CAAKtD,iBAAAA,CAAkBvF,SAAAA,CAAUwJ,EAAc7J,GAAAA,EAC/CkJ,IAAAA,CAAKzD,uBAAAA,CAAwBc,MAAAA,CAAO4G,EAAO,EAAA,CAEnD,CAEA,IAAK,IAAIA,EAAQ,EAAGA,EAAQjE,IAAAA,CAAKxD,iBAAAA,CAAkB7T,MAAAA,CAAQsb,IAAS,CAChE,IAAMtD,EAAgBX,IAAAA,CAAKxD,iBAAAA,CAAkByH,EAAAA,AACzCD,CAAAA,EAA2B5G,GAAAA,CAAIuD,EAAc7J,GAAAA,GAC7CkJ,CAAAA,IAAAA,CAAKrD,aAAAA,CAAcxF,SAAAA,CAAUwJ,EAAc7J,GAAAA,EAC3CkJ,IAAAA,CAAKxD,iBAAAA,CAAkBa,MAAAA,CAAO4G,EAAO,EAAA,CAE7C,CAGAF,EAAwBlN,OAAAA,CAAQ,SAAC6J,CAAAA,EAC7B,IAAMwD,EACFhE,EAAKzD,sBAAAA,CAAuB3M,IAAAA,CACxB,SAAC6Q,CAAAA,EAAa,OAAKA,EAAc7J,GAAAA,GAAQ4J,CAAc,GAEzDyD,EAAsBjE,EAAK9J,cAAAA,CAAetG,IAAAA,CAC5C,SAAC6Q,CAAAA,EAAAA,OAAkBA,EAAc7J,GAAAA,GAAQ4J,CAAc,EAGvDwD,CAAAA,GACAhE,EAAK5C,yBAAAA,CAA0B4G,GAE/BC,GACAjE,CAAAA,EAAK9J,cAAAA,CAAiB8J,EAAK9J,cAAAA,CAAerN,MAAAA,CACtC,SAACqb,CAAAA,EAAiB,OACdA,EAAkBnM,EAAAA,EAAMkM,EAAoBlM,EAAE,AAAA,EAAA,CAG9D,EAAA,CACJ,EAACgI,EAOD1C,iBAAAA,CAAA,SAAkB8G,CAAAA,EAEd,IAAMZ,EAAkBY,EAAcxH,gBAAAA,CAAiB,iBAGjDyH,EAAgB,EAAA,CACtBtE,IAAAA,CAAK5J,cAAAA,CAAeS,OAAAA,CAAQ,SAAC8J,CAAAA,EACzB2D,EAAIxb,IAAAA,CAAK6X,EAAc1I,EAAAA,CAC3B,GACA,IACMsM,EADQhgB,KAAKD,GAAAA,CAAGyC,KAAAA,CAARxC,KAAY+f,EAAGtH,MAAAA,CAAE,CAAA,EAAA,GACL,EACpB0G,EAAqB1D,IAAAA,CAAKlD,cAAAA,CAAe2G,GAC/CzD,IAAAA,CAAKjD,wBAAAA,CACD2G,EACAa,EAAAA,CACA,EAER,EAACtE,EAWDlD,wBAAAA,CAAA,SACI0G,CAAAA,CACAc,CAAAA,CACAC,CAAAA,EAAAA,KADAD,IAAAA,GAAAA,CAAAA,EAAY,CAAA,EAAA,KACZC,IAAAA,GAAAA,CAAAA,EAAAA,CAAY,CAAA,EAGZ,IAAK,IAAIP,EAAQ,EAAGA,EAAQR,EAAgB9a,MAAAA,CAAQsb,IAAS,CACzD,IAAMvD,EAAiB+C,CAAAA,CAAgBQ,EAAAA,CACjC1L,EAAUyH,IAAAA,CAAKxC,eAAAA,CAAgBkD,GAE/B+D,EAAwB,IAAInD,EAAc,CAC5CxK,IAAK4J,EACLzI,GAAIsM,EAAYN,EAChBzL,kBAAmBwH,IAAAA,CAAKxH,iBAAAA,CACxBE,cAAesH,IAAAA,CAAKtH,aAAAA,CACpBP,yBACI6H,IAAAA,CAAKvC,uBAAAA,CAAwBlI,IAAAA,CAAKyK,IAAAA,EACtC3H,2BACI2H,IAAAA,CAAK1C,yBAAAA,CAA0B/H,IAAAA,CAAKyK,IAAAA,EACxCzH,QAAAA,CAAAA,EAIJyH,CAAAA,IAAAA,CAAK5J,cAAAA,CAAetN,IAAAA,CAAK2b,GAGrBlM,EACAyH,CAAAA,IAAAA,CAAKxD,iBAAAA,CAAkB1T,IAAAA,CAAK2b,GAGxBD,GACAxE,CAAAA,IAAAA,CAAKrD,aAAAA,CAAcvG,cAAAA,CAAetN,IAAAA,CAC9B2b,GAEJzE,IAAAA,CAAKrD,aAAAA,CAActV,OAAAA,CAAQod,EAAsB3N,GAAAA,CAAAA,CAAAA,EAGrDkJ,CAAAA,IAAAA,CAAKzD,uBAAAA,CAAwBzT,IAAAA,CAAK2b,GAG9BD,GACAxE,CAAAA,IAAAA,CAAKtD,iBAAAA,CAAkBtG,cAAAA,CAAetN,IAAAA,CAClC2b,GAEJzE,IAAAA,CAAKtD,iBAAAA,CAAkBrV,OAAAA,CAAQod,EAAsB3N,GAAAA,CAAAA,CAAAA,CAGjE,CACJ,EAACmJ,EAODhD,6BAAAA,CAAA,WAEI,IAAA,IAA+CyH,EAA/CC,EAAAlE,EAA4BT,IAAAA,CAAK5J,cAAAA,EAAAA,CAAcsO,AAAAA,CAAAA,EAAAC,GAAAA,EAAA/O,IAAAA,EAAvB8O,EAAAhgB,KAAAA,CACNiD,OAAAA,EAGlBqY,CAAAA,IAAAA,CAAK5J,cAAAA,CAAiB,EAAA,CACtB4J,IAAAA,CAAKxD,iBAAAA,CAAoB,EAAA,CACzBwD,IAAAA,CAAKzD,uBAAAA,CAA0B,EAAA,CAC/ByD,IAAAA,CAAKvD,sBAAAA,CAAyB,EAClC,AAAA,EAACwD,EAUDxC,uBAAAA,CAAA,SAAwBkD,CAAAA,EACpBX,IAAAA,CAAKvD,sBAAAA,CAAuB3T,IAAAA,CAAK6X,EACrC,EAACV,EAUD3C,yBAAAA,CAAA,SAA0BqD,CAAAA,EACtBX,IAAAA,CAAKvD,sBAAAA,CAAyBuD,IAAAA,CAAKvD,sBAAAA,CAAuB1T,MAAAA,CACtD,SAAC6b,CAAAA,EAAqB,OAClBA,EAAsB3M,EAAAA,EAAM0I,EAAc1I,EAAE,AAAA,EAExD,EAACgI,EAWOnD,cAAAA,CAAA,SAAe+H,CAAAA,EACnB,OAAO5P,MAAMtQ,IAAAA,CAAKkgB,EACtB,EAAC5E,EAWDzC,eAAAA,CAAA,SAAgBkD,CAAAA,EACZ,IAAIoE,EAAqB,EAAA,CAAA9H,MAAAA,CAAOuG,GAG1BwB,EAAkB,SAACC,CAAAA,EACrBF,EAAwBA,EAAsB/b,MAAAA,CAC1C,SAACkc,CAAAA,EAAS,OAAKA,IAAcD,CAAiB,EAEtD,EAGA,GAAItE,EAAe7G,OAAAA,CAAQC,YAAAA,CAAc,CAKrC,GA/UkB,QA2UJ4G,EAAe7G,OAAAA,CAAQC,YAAAA,CAChC7J,KAAAA,CAAM,KACNyN,GAAAA,CAAI,SAAC/H,CAAAA,EAAAA,OAASA,EAAKb,OAAAA,CAAQ,IAAK,IAAID,IAAAA,EAAM,GAC1C8I,IAAAA,CAAK,KAEN,MAAA,CAAO,EAEPoH,EAAgB,eAExB,MACIA,EAAgB,gBAIpB,GAAIrE,EAAe7G,OAAAA,CAAQE,cAAAA,CAAgB,CAEvC,GA1VoB,eAyVN2G,EAAe7G,OAAAA,CAAQE,cAAAA,CAAelF,IAAAA,GAEhD,MAAA,CAAA,EAEAkQ,EAAgB,iBAExB,MACIA,EAAgB,kBAIpB,GACIrE,EAAe7G,OAAAA,CAAQK,WAAAA,EAAAA,CACtBa,MAAMZ,WAAWuG,EAAe7G,OAAAA,CAAQK,WAAAA,GAEzC,MAAA,CAAA,EAEA6K,EAAgB,eAIpB,IAAAG,IAA6CC,EAA7CD,EAAAzE,EAAwBqE,GAAAA,CAAqBK,AAAAA,CAAAA,EAAAD,GAAAA,EAAAtP,IAAAA,EACzC,GADgBuP,EAAAzgB,KAAAA,IACCgc,EAAe7G,OAAAA,CAC5B,MAAA,CAAO,EAIf,MAAA,CAAA,CACJ,EAAC2J,CAAA,IC1XgB4B,EAAgB,WAqBjC,SAAAA,EAAAC,CAAAA,EAQgC,IAAAxF,EAAAA,KAAAA,IAAAwF,EAAF,CAAA,EAAEA,EAAAC,EAAAzF,EAP5BhC,YAAAA,CACAzB,EAAiByD,EAAjBzD,iBAAAA,CACAC,EAAawD,EAAbxD,aAAAA,CAAakJ,EAAA1F,EACb/B,SAAAA,CAAgB0H,EAAA3F,EAChB9B,cAAAA,CACAC,EAAgB6B,EAAhB7B,gBAAAA,CACAC,EAAmB4B,EAAnB5B,mBAAAA,AA3BGC,CAAAA,IAAAA,CAAAA,UAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CACAxF,aAAAA,CAA8B,KAE7ByF,IAAAA,CAAAA,YAAAA,CAA4B,KAAA,IAAA,CAE5BN,YAAAA,CAAAA,KAAY,EAAAmC,IAAAA,CACZ5D,iBAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CACA+B,WAAAA,CAAAA,KAAW,EAAA4B,IAAAA,CACXlC,SAAAA,CAAAA,KACAO,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CAEAL,gBAAAA,CAAAA,KAAgB,EAAAgC,IAAAA,CAChB/B,mBAAAA,CAAAA,KACAK,EAAAA,IAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAAAA,IAAAA,CACAC,aAAAA,CAAAA,KAAa,EAAAyB,IAAAA,CACbxB,eAAAA,CAAAA,KAAe,EAAAwB,IAAAA,CACfvB,wBAAAA,CAAAA,KACAC,EAAAA,IAAAA,CAAAA,wBAAAA,CAAAA,KAAAA,EAaJzX,OAAO0X,uBAAAA,CAAAA,QAGP5I,OAAOC,MAAAA,CAAOgK,IAAAA,CAAM,CAChBnC,aAdJA,KAAe,IAAHyH,EAAG,CAAA,EAAEA,EAeblJ,kBAAAA,EACAC,cAAAA,EACAyB,UAdJA,KAAAA,IAASyH,GAAOA,EAeZxH,eAdJA,KAAc,IAAAyH,EAAG,WAAO,EAACA,EAerBxH,iBAAAA,EACAC,oBAAAA,CAAAA,GAKJ+B,IAAAA,CAAK1B,aAAAA,CAAgB0B,IAAAA,CAAKpB,SAAAA,CAAUrJ,IAAAA,CAAKyK,IAAAA,EACzCA,IAAAA,CAAKxB,eAAAA,CAAkBwB,IAAAA,CAAKnB,WAAAA,CAAYtJ,IAAAA,CAAKyK,IAAAA,EAC7CA,IAAAA,CAAKzB,aAAAA,CAAgByB,IAAAA,CAAKlB,SAAAA,CAAUvJ,IAAAA,CAAKyK,IAAAA,EAGzCA,IAAAA,CAAK9B,UAAAA,CAAAA,CAAa,EAGlB8B,IAAAA,CAAK3B,aAAAA,CAAgB,iBAAkBpX,QAAU8X,UAAUC,cAAAA,CAAiB,EAG5EgB,IAAAA,CAAKtJ,KAAAA,EACT,CAAC,IAAAuJ,EAAAmF,EAAAzO,SAAAA,CAwSA,OAxSAsJ,EAOOvJ,KAAAA,CAAA,WAAK,IAAAwJ,EAGTF,IAAAA,AAAAA,CAAAA,IAAAA,CAAKtH,aAAAA,CAAgB,IAAI+M,EAAKC,EAAAA,CAAAA,EACvB1F,IAAAA,CAAKnC,YAAAA,GAIRmC,IAAAA,CAAKjC,cAAAA,EACLiC,IAAAA,CAAKtH,aAAAA,CAAc9P,EAAAA,CAAG,SAAUoX,IAAAA,CAAKjC,cAAAA,EAIzClS,SAASC,eAAAA,CAAgBmT,YAAAA,CACrB,0BACAe,IAAAA,CAAKtH,aAAAA,CAAcpP,OAAAA,CAAQ+C,WAAAA,EAG/BuB,sBAAsB,WAGlBsS,EAAK/B,YAAAA,CAAe,IAAIqF,EAAK,CACzB1M,IAAKoJ,EAAKxH,aAAAA,CAAehL,WAAAA,CACzB0O,kBAAmB8D,EAAK9D,iBAAAA,CACxBC,cAAe6D,EAAK7D,aAAAA,CACpB7D,kBAAmB0H,EAAKxH,aAAAA,CAAepP,OAAAA,CAAQ+C,WAAAA,CAC/CqM,cAAewH,EAAKxH,aAAAA,AAAAA,GAIxBwH,EAAKhB,WAAAA,GAGDgB,EAAKlC,gBAAAA,EAAAA,CAAqBkC,EAAKjC,mBAAAA,CAC/BxL,QAAQC,IAAAA,CACJ,wHAAA,CAEIwN,EAAKlC,gBAAAA,EAAoBkC,EAAKjC,mBAAAA,EACtCxL,QAAQC,IAAAA,CACJ,wHAKRwN,EAAKpC,SAAAA,EAAaoC,EAAKnO,KAAAA,EAC3B,EACJ,EAACkO,EAKMtY,OAAAA,CAAA,WAAO,IAAAge,EAAAC,EAAAA,IAAAA,AAEV5F,CAAAA,IAAAA,CAAKna,IAAAA,GAELma,IAAAA,CAAKb,aAAAA,GAELwG,MAAAA,CAAAA,EAAI3F,IAAAA,CAACtH,aAAAA,AAAAA,GAALiN,EAAoBhe,OAAAA,GAIpBiG,sBAAsB,WAAA,IAAKiY,CACvBA,OAAAA,CAAAA,EAAAD,EAAKzH,YAAAA,AAAAA,GAAL0H,EAAmBle,OAAAA,EACvB,EACJ,EAACsY,EAKOf,WAAAA,CAAA,WAAW4G,IAAAA,EAAAA,IAAAA,AACf9F,CAAAA,IAAAA,CAAKZ,mBAAAA,GAKDY,IAAAA,CAAKtH,aAAAA,EACLsH,CAAAA,IAAAA,CAAKvB,wBAAAA,CAA2BuB,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW5D,eAAAA,CAAgBwN,IAAAA,CAC1EyK,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,EAEvBqU,IAAAA,CAAKtB,wBAAAA,CAA2BsB,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW7D,eAAAA,CAAgByN,IAAAA,CAC1EyK,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,EAGvBqU,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW5D,eAAAA,CAAkB,WAAA,MAC5C+d,EAAKrH,wBAAAA,EAALqH,EAAKrH,wBAAAA,GACLqH,EAAKvH,aAAAA,EACT,EAEAyB,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW7D,eAAAA,CAAkB,WACf,MAA7Bge,EAAKpH,wBAAAA,EAALoH,EAAKpH,wBAAAA,GACLoH,EAAKvH,aAAAA,EACT,CAAA,CAER,EAAC0B,EAKOd,aAAAA,CAAA,WACJa,IAAAA,CAAKX,qBAAAA,GAGDW,IAAAA,CAAKtH,aAAAA,EACDsH,CAAAA,IAAAA,CAAKvB,wBAAAA,EACLuB,CAAAA,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW5D,eAAAA,CAAkBiY,IAAAA,CAAKvB,wBAAAA,AAAAA,EAErDuB,IAAAA,CAAKtB,wBAAAA,EACLsB,CAAAA,IAAAA,CAAKtH,aAAAA,CAAc/M,UAAAA,CAAW7D,eAAAA,CAAkBkY,IAAAA,CAAKtB,wBAAAA,AAAAA,CAAAA,CAGjE,EAACuB,EAKOb,mBAAAA,CAAA,SAAoB2G,CAAAA,EAAwBC,IAAAA,EAAAC,EAAAjG,IAAAA,CAC1CkG,EAAiBH,GAEC,CAAA,MADRC,CAAAA,EACVhG,IAAAA,CAAKtH,aAAAA,AAAAA,EAAAA,KAAa,EAAlBsN,EAAoBtY,WAAAA,AAAAA,EACpByY,EACFD,MAAAA,EAAAA,KAAAA,EAAAA,EAAgBrJ,gBAAAA,CAAiB,mBAEpB,CAAA,CAAA,MAAjBsJ,EAAAA,KAAiB,EAAjBA,EAAmBxd,MAAAA,AAAAA,GACfwd,EAAkBtP,OAAAA,CAAQ,SAACC,CAAAA,EACtBA,EAAoB5P,gBAAAA,CAAiB,QAAS+e,EAAKzH,eAAAA,CAAAA,CAAiB,EACzE,EACR,EAACyB,EAKOZ,qBAAAA,CAAA,SAAsB0G,CAAAA,EAAwBK,IAAAA,EAAAC,EAAArG,IAAAA,CAC5CkG,EAAiBH,GAEjBK,CAAAA,MADUA,CAAAA,EACVpG,IAAAA,CAAKtH,aAAAA,AAAAA,EAAAA,KAAL0N,EAAAA,EAAoB1Y,WAAAA,AAAAA,EACpByY,EAAAA,MACFD,EAAAA,KAAAA,EAAAA,EAAgBrJ,gBAAAA,CAAiB,mBACrCsJ,CAAAA,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAmBxd,MAAAA,AAAAA,GACfwd,EAAkBtP,OAAAA,CAAQ,SAACC,CAAAA,EACtBA,EAAoBjP,mBAAAA,CAAoB,QAASwe,EAAK7H,eAAAA,CAAAA,CAAiB,EAC5E,EACR,EAACyB,EAQOnB,SAAAA,CAAA,WAASwH,IAAAA,EAAAC,EAAAC,CACI,OAAjBF,CAAAA,EAAAtG,IAAAA,CAAK7B,YAAAA,AAAAA,GAALmI,EAAmB3L,QAAAA,CAAS,CACxB9B,cAAyC0N,MAA5BA,CAAAA,EAAAA,MAAAC,CAAAA,EAAExG,IAAAA,CAAKtH,aAAAA,AAAAA,EAAAA,KAAAA,EAAL8N,EAAoBtX,MAAAA,AAAAA,EAAMqX,EAAI,EAC7C1L,OAAAA,CAASmF,IAAAA,CAAK3B,aAAAA,AAAAA,EAEtB,EAAC4B,EAKOrB,SAAAA,CAAA,WAAS6H,IAAAA,EAAAC,EAAAC,EAAAC,CACbH,OAAAA,CAAAA,EAAIzG,IAAAA,CAACtH,aAAAA,AAAAA,GAAL+N,EAAoB5Y,GAAAA,CAAI2F,KAAKC,GAAAA,IAE7BiT,MAAAA,CAAAA,EAAI1G,IAAAA,CAAC7B,YAAAA,AAAAA,GAALuI,EAAmB9L,QAAAA,CAAS,CACxB/B,cAAyC8N,MAA5BA,CAAAA,EAAoB,MAApBC,CAAAA,EAAE5G,IAAAA,CAAKtH,aAAAA,AAAAA,EAAAA,KAAa,EAAlBkO,EAAoB1X,MAAAA,AAAAA,EAAMyX,EAAI,EAC7C9L,OAAAA,CAASmF,IAAAA,CAAK3B,aAAAA,AAAAA,EAEtB,EAAC4B,EAKOpB,WAAAA,CAAA,SAAYrW,CAAAA,EAChBA,EAAM8I,cAAAA,GACN,IAFiCuV,EAAAC,EAE3BC,EAA8CF,MAAvCA,CAAAA,EAAIre,EAAM8W,aAAAA,AAAAA,EAA6BuH,EAAI,KACxD,GAAKE,EAAL,CACA,IAAM/W,EACF+W,EAAQnX,YAAAA,CAAa,wBACrBmX,EAAQnX,YAAAA,CAAa,QACnBuC,EAAS4U,EAAQnX,YAAAA,CAAa,0BAA4B,EAC1D7K,EACFgiB,EAAQnX,YAAAA,CAAa,4BACH,CAAA,MAD6BkX,CAAAA,EAC/C9G,IAAAA,CAAKtH,aAAAA,AAAAA,EAAAA,KAAa,EAAlBoO,EAAoBxd,OAAAA,CAAQvE,QAAAA,AAAAA,CAChCiL,CAAAA,GACIgQ,IAAAA,CAAK7Q,QAAAA,CAASa,EAAQ,CAClBmC,OAA0B,UAAA,OAAXA,EAAsBwJ,SAASxJ,GAAUA,EACxDpN,SACwB,UAAA,OAAbA,EACD4W,SAAS5W,GACTA,CAAAA,EAdJ,CAgBlB,EAACkb,EAKMlO,KAAAA,CAAA,WAAKiV,IAAAA,CACJhH,CAAAA,IAAAA,CAAK9B,UAAAA,EAKT8I,CAAAA,MAAAA,CAAAA,EAAIhH,IAAAA,CAACtH,aAAAA,AAAAA,GAALsO,EAAoBjV,KAAAA,GAEpBiO,IAAAA,CAAK9B,UAAAA,CAAAA,CAAa,EAClB8B,IAAAA,CAAKhC,gBAAAA,CACCgC,IAAAA,CAAKhC,gBAAAA,CAAiBgC,IAAAA,CAAK1B,aAAAA,EAC3B0B,IAAAA,CAAKT,IAAAA,EAAAA,CACf,EAACU,EAKMpa,IAAAA,CAAA,WAAI,IAAAohB,CACFjH,CAAAA,IAAAA,CAAK9B,UAAAA,EAKQ,CAAA,MAAlB+I,CAAAA,EAAAjH,IAAAA,CAAKtH,aAAAA,AAAAA,GAALuO,EAAoBphB,IAAAA,GAEpBma,IAAAA,CAAK9B,UAAAA,CAAAA,CAAa,EAClB8B,IAAAA,CAAK/B,mBAAAA,CACC+B,IAAAA,CAAK/B,mBAAAA,CAAoB+B,IAAAA,CAAK1B,aAAAA,EAC9B0B,IAAAA,CAAK5B,WAAAA,EAAerQ,qBAAqBiS,IAAAA,CAAK5B,WAAAA,CAAAA,CACxD,EAAC6B,EAKM/C,oBAAAA,CAAA,SAAqB4G,CAAAA,EAA0BoD,IAAAA,CAC7CpD,CAAAA,EAKL9D,CAAAA,IAAAA,CAAKX,qBAAAA,CAAsByE,GAC3BoD,MAAAA,CAAAA,EAAIlH,IAAAA,CAAC7B,YAAAA,AAAAA,GAAL+I,EAAmBhK,oBAAAA,CAAqB4G,EAAAA,EALpCrR,QAAQmK,KAAAA,CAAM,gDAMtB,EAACqD,EAKM1C,iBAAAA,CAAA,SAAkB8G,CAAAA,EAA0B,IAAA8C,EAAAC,EAAAA,IAAAA,AAC1C/C,CAAAA,EAAAA,CAAAA,MAKL8C,CAAAA,EAAAA,IAAAA,CAAKhJ,YAAAA,AAAAA,GAALgJ,EAAmB5J,iBAAAA,CAAkB8G,GACrCzW,sBAAsB,WAClBwZ,EAAKhI,mBAAAA,CAAoBiF,EAC7B,EAAA,EAPI5R,QAAQmK,KAAAA,CAAM,gDAQtB,EAACqD,EAKMvZ,MAAAA,CAAA,WACHsZ,IAAAA,CAAKzB,aAAAA,EACT,EAAC0B,EAKM9Q,QAAAA,CAAA,SACHa,CAAAA,CACA1G,CAAAA,EAA+B+d,IAAAA,CAAAA,OAE/BA,CAAAA,EAAAA,IAAAA,CAAK3O,aAAAA,AAAAA,GAAL2O,EAAoBlY,QAAAA,CAASa,EAAQ,CACjCmC,OAAAA,MAAQ7I,EAAAA,KAAAA,EAAAA,EAAS6I,MAAAA,CACjBrN,KAAa,MAAPwE,EAAAA,KAAO,EAAPA,EAASxE,IAAAA,CACfC,SAAiB,MAAPuE,EAAAA,KAAO,EAAPA,EAASvE,QAAAA,CACnBqN,UAAW9I,MAAAA,EAAAA,KAAAA,EAAAA,EAAS8I,SAAAA,CACpBC,KAAM/I,MAAAA,EAAAA,KAAAA,EAAAA,EAAS+I,IAAAA,CACfE,MAAOjJ,MAAAA,EAAAA,KAAAA,EAAAA,EAASiJ,KAAAA,CAChBvN,OAAAA,MAAQsE,EAAAA,KAAAA,EAAAA,EAAStE,MAAAA,CACjBsN,WAAmB,MAAPhJ,EAAAA,KAAO,EAAPA,EAASgJ,UAAAA,AAAAA,EAE7B,EAAC2N,EAQOV,IAAAA,CAAA,WAAI+H,IAAAA,EAAAA,IAAAA,AACRtH,CAAAA,IAAAA,CAAK1B,aAAAA,GACL0B,IAAAA,CAAK5B,WAAAA,CAAcxQ,sBAAsB,WAAA,OAAM0Z,EAAK/H,IAAAA,EAAM,EAC9D,EAAC6F,CAAA,INhXL,IAAI,EAAS,KAEb,OAAO,gBAAgB,CAAC,OAAQ,KAC9B,IAAM,EAAY,SAAS,aAAa,CAAC,2BACpC,IAEL,EAAS,IAAI,EAAiB,CAC5B,GAAI,EACJ,OAAQ,CAAA,CACV,GAEA,OAAO,gBAAgB,CAAC,SAAU,KAC5B,GACF,EAAO,MAAM,EAEjB,GACF","sources":["<anon>","js/scroll.js","node_modules/locomotive-scroll/dist/locomotive-scroll.mjs","node_modules/locomotive-scroll/core/IO.ts","node_modules/locomotive-scroll/utils/maths.ts","node_modules/locomotive-scroll/core/ScrollElement.ts","node_modules/locomotive-scroll/core/Core.ts","node_modules/locomotive-scroll/index.ts","node_modules/lenis/dist/lenis.mjs","node_modules/lenis/package.json","node_modules/lenis/packages/core/src/maths.ts","node_modules/lenis/packages/core/src/animate.ts","node_modules/lenis/packages/core/src/debounce.ts","node_modules/lenis/packages/core/src/dimensions.ts","node_modules/lenis/packages/core/src/emitter.ts","node_modules/lenis/packages/core/src/virtual-scroll.ts","node_modules/lenis/packages/core/src/lenis.ts"],"sourcesContent":["// import 'locomotive-scroll/dist/locomotive-scroll.css';\n// import LocomotiveScroll from 'locomotive-scroll';\n// const scroll = new LocomotiveScroll();\n// console.log('scroll initialized');\n// package.json\nvar $8ecb29f509dc0bd0$var$version = \"1.3.17\";\n// packages/core/src/maths.ts\nfunction $8ecb29f509dc0bd0$var$clamp(min, input, max) {\n    return Math.max(min, Math.min(input, max));\n}\nfunction $8ecb29f509dc0bd0$var$lerp(x, y, t) {\n    return (1 - t) * x + t * y;\n}\nfunction $8ecb29f509dc0bd0$var$damp(x, y, lambda, deltaTime) {\n    return $8ecb29f509dc0bd0$var$lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction $8ecb29f509dc0bd0$var$modulo(n, d) {\n    return (n % d + d) % d;\n}\n// packages/core/src/animate.ts\nvar $8ecb29f509dc0bd0$var$Animate = class {\n    isRunning = false;\n    value = 0;\n    from = 0;\n    to = 0;\n    currentTime = 0;\n    // These are instanciated in the fromTo method\n    lerp;\n    duration;\n    easing;\n    onUpdate;\n    /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */ advance(deltaTime) {\n        if (!this.isRunning) return;\n        let completed = false;\n        if (this.duration && this.easing) {\n            this.currentTime += deltaTime;\n            const linearProgress = $8ecb29f509dc0bd0$var$clamp(0, this.currentTime / this.duration, 1);\n            completed = linearProgress >= 1;\n            const easedProgress = completed ? 1 : this.easing(linearProgress);\n            this.value = this.from + (this.to - this.from) * easedProgress;\n        } else if (this.lerp) {\n            this.value = $8ecb29f509dc0bd0$var$damp(this.value, this.to, this.lerp * 60, deltaTime);\n            if (Math.round(this.value) === this.to) {\n                this.value = this.to;\n                completed = true;\n            }\n        } else {\n            this.value = this.to;\n            completed = true;\n        }\n        if (completed) this.stop();\n        this.onUpdate?.(this.value, completed);\n    }\n    /** Stop the animation */ stop() {\n        this.isRunning = false;\n    }\n    /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */ fromTo(from, to, { lerp: lerp2, duration: duration, easing: easing, onStart: onStart, onUpdate: onUpdate }) {\n        this.from = this.value = from;\n        this.to = to;\n        this.lerp = lerp2;\n        this.duration = duration;\n        this.easing = easing;\n        this.currentTime = 0;\n        this.isRunning = true;\n        onStart?.();\n        this.onUpdate = onUpdate;\n    }\n};\n// packages/core/src/debounce.ts\nfunction $8ecb29f509dc0bd0$var$debounce(callback, delay) {\n    let timer;\n    return function(...args) {\n        let context = this;\n        clearTimeout(timer);\n        timer = setTimeout(()=>{\n            timer = void 0;\n            callback.apply(context, args);\n        }, delay);\n    };\n}\n// packages/core/src/dimensions.ts\nvar $8ecb29f509dc0bd0$var$Dimensions = class {\n    constructor(wrapper, content, { autoResize: autoResize = true, debounce: debounceValue = 250 } = {}){\n        this.wrapper = wrapper;\n        this.content = content;\n        if (autoResize) {\n            this.debouncedResize = $8ecb29f509dc0bd0$var$debounce(this.resize, debounceValue);\n            if (this.wrapper instanceof Window) window.addEventListener(\"resize\", this.debouncedResize, false);\n            else {\n                this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n                this.wrapperResizeObserver.observe(this.wrapper);\n            }\n            this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n            this.contentResizeObserver.observe(this.content);\n        }\n        this.resize();\n    }\n    width = 0;\n    height = 0;\n    scrollHeight = 0;\n    scrollWidth = 0;\n    // These are instanciated in the constructor as they need information from the options\n    debouncedResize;\n    wrapperResizeObserver;\n    contentResizeObserver;\n    destroy() {\n        this.wrapperResizeObserver?.disconnect();\n        this.contentResizeObserver?.disconnect();\n        if (this.wrapper === window && this.debouncedResize) window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n    resize = ()=>{\n        this.onWrapperResize();\n        this.onContentResize();\n    };\n    onWrapperResize = ()=>{\n        if (this.wrapper instanceof Window) {\n            this.width = window.innerWidth;\n            this.height = window.innerHeight;\n        } else {\n            this.width = this.wrapper.clientWidth;\n            this.height = this.wrapper.clientHeight;\n        }\n    };\n    onContentResize = ()=>{\n        if (this.wrapper instanceof Window) {\n            this.scrollHeight = this.content.scrollHeight;\n            this.scrollWidth = this.content.scrollWidth;\n        } else {\n            this.scrollHeight = this.wrapper.scrollHeight;\n            this.scrollWidth = this.wrapper.scrollWidth;\n        }\n    };\n    get limit() {\n        return {\n            x: this.scrollWidth - this.width,\n            y: this.scrollHeight - this.height\n        };\n    }\n};\n// packages/core/src/emitter.ts\nvar $8ecb29f509dc0bd0$var$Emitter = class {\n    events = {};\n    /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */ emit(event, ...args) {\n        let callbacks = this.events[event] || [];\n        for(let i = 0, length = callbacks.length; i < length; i++)callbacks[i]?.(...args);\n    }\n    /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */ on(event, cb) {\n        this.events[event]?.push(cb) || (this.events[event] = [\n            cb\n        ]);\n        return ()=>{\n            this.events[event] = this.events[event]?.filter((i)=>cb !== i);\n        };\n    }\n    /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */ off(event, callback) {\n        this.events[event] = this.events[event]?.filter((i)=>callback !== i);\n    }\n    /**\n   * Remove all event listeners and clean up\n   */ destroy() {\n        this.events = {};\n    }\n};\n// packages/core/src/virtual-scroll.ts\nvar $8ecb29f509dc0bd0$var$LINE_HEIGHT = 100 / 6;\nvar $8ecb29f509dc0bd0$var$listenerOptions = {\n    passive: false\n};\nvar $8ecb29f509dc0bd0$var$VirtualScroll = class {\n    constructor(element, options = {\n        wheelMultiplier: 1,\n        touchMultiplier: 1\n    }){\n        this.element = element;\n        this.options = options;\n        window.addEventListener(\"resize\", this.onWindowResize, false);\n        this.onWindowResize();\n        this.element.addEventListener(\"wheel\", this.onWheel, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.addEventListener(\"touchstart\", this.onTouchStart, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.addEventListener(\"touchmove\", this.onTouchMove, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.addEventListener(\"touchend\", this.onTouchEnd, $8ecb29f509dc0bd0$var$listenerOptions);\n    }\n    touchStart = {\n        x: 0,\n        y: 0\n    };\n    lastDelta = {\n        x: 0,\n        y: 0\n    };\n    window = {\n        width: 0,\n        height: 0\n    };\n    emitter = new $8ecb29f509dc0bd0$var$Emitter();\n    /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */ on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    /** Remove all event listeners and clean up */ destroy() {\n        this.emitter.destroy();\n        window.removeEventListener(\"resize\", this.onWindowResize, false);\n        this.element.removeEventListener(\"wheel\", this.onWheel, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.removeEventListener(\"touchstart\", this.onTouchStart, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.removeEventListener(\"touchmove\", this.onTouchMove, $8ecb29f509dc0bd0$var$listenerOptions);\n        this.element.removeEventListener(\"touchend\", this.onTouchEnd, $8ecb29f509dc0bd0$var$listenerOptions);\n    }\n    /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */ onTouchStart = (event)=>{\n        const { clientX: clientX, clientY: clientY } = event.targetTouches ? event.targetTouches[0] : event;\n        this.touchStart.x = clientX;\n        this.touchStart.y = clientY;\n        this.lastDelta = {\n            x: 0,\n            y: 0\n        };\n        this.emitter.emit(\"scroll\", {\n            deltaX: 0,\n            deltaY: 0,\n            event: event\n        });\n    };\n    /** Event handler for 'touchmove' event */ onTouchMove = (event)=>{\n        const { clientX: clientX, clientY: clientY } = event.targetTouches ? event.targetTouches[0] : event;\n        const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n        const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n        this.touchStart.x = clientX;\n        this.touchStart.y = clientY;\n        this.lastDelta = {\n            x: deltaX,\n            y: deltaY\n        };\n        this.emitter.emit(\"scroll\", {\n            deltaX: deltaX,\n            deltaY: deltaY,\n            event: event\n        });\n    };\n    onTouchEnd = (event)=>{\n        this.emitter.emit(\"scroll\", {\n            deltaX: this.lastDelta.x,\n            deltaY: this.lastDelta.y,\n            event: event\n        });\n    };\n    /** Event handler for 'wheel' event */ onWheel = (event)=>{\n        let { deltaX: deltaX, deltaY: deltaY, deltaMode: deltaMode } = event;\n        const multiplierX = deltaMode === 1 ? $8ecb29f509dc0bd0$var$LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n        const multiplierY = deltaMode === 1 ? $8ecb29f509dc0bd0$var$LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n        deltaX *= multiplierX;\n        deltaY *= multiplierY;\n        deltaX *= this.options.wheelMultiplier;\n        deltaY *= this.options.wheelMultiplier;\n        this.emitter.emit(\"scroll\", {\n            deltaX: deltaX,\n            deltaY: deltaY,\n            event: event\n        });\n    };\n    onWindowResize = ()=>{\n        this.window = {\n            width: window.innerWidth,\n            height: window.innerHeight\n        };\n    };\n};\n// packages/core/src/lenis.ts\nvar $8ecb29f509dc0bd0$var$defaultEasing = (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar $8ecb29f509dc0bd0$export$2e2bcd8739ae039 = class {\n    _isScrolling = false;\n    // true when scroll is animating\n    _isStopped = false;\n    // true if user should not be able to scroll - enable/disable programmatically\n    _isLocked = false;\n    // same as isStopped but enabled/disabled when scroll reaches target\n    _preventNextNativeScrollEvent = false;\n    _resetVelocityTimeout = null;\n    _rafId = null;\n    /**\n   * Whether or not the user is touching the screen\n   */ isTouching;\n    /**\n   * The time in ms since the lenis instance was created\n   */ time = 0;\n    /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */ userData = {};\n    /**\n   * The last velocity of the scroll\n   */ lastVelocity = 0;\n    /**\n   * The current velocity of the scroll\n   */ velocity = 0;\n    /**\n   * The direction of the scroll\n   */ direction = 0;\n    /**\n   * The options passed to the lenis instance\n   */ options;\n    /**\n   * The target scroll value\n   */ targetScroll;\n    /**\n   * The animated scroll value\n   */ animatedScroll;\n    // These are instanciated here as they don't need information from the options\n    animate = new $8ecb29f509dc0bd0$var$Animate();\n    emitter = new $8ecb29f509dc0bd0$var$Emitter();\n    // These are instanciated in the constructor as they need information from the options\n    dimensions;\n    // This is not private because it's used in the Snap class\n    virtualScroll;\n    constructor({ wrapper: wrapper = window, content: content = document.documentElement, eventsTarget: eventsTarget = wrapper, smoothWheel: smoothWheel = true, syncTouch: syncTouch = false, syncTouchLerp: syncTouchLerp = 0.075, touchInertiaExponent: touchInertiaExponent = 1.7, duration: duration, easing: // in seconds\n    easing, lerp: lerp2 = 0.1, infinite: infinite = false, orientation: orientation = \"vertical\", gestureOrientation: // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\", touchMultiplier: // vertical, horizontal, both\n    touchMultiplier = 1, wheelMultiplier: wheelMultiplier = 1, autoResize: autoResize = true, prevent: prevent, virtualScroll: virtualScroll, overscroll: overscroll = true, autoRaf: autoRaf = false, anchors: anchors = false, autoToggle: autoToggle = false, allowNestedScroll: // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false, __experimental__naiveDimensions: // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false, naiveDimensions: naiveDimensions = __experimental__naiveDimensions, stopInertiaOnNavigate: stopInertiaOnNavigate = false } = {}){\n        window.lenisVersion = $8ecb29f509dc0bd0$var$version;\n        if (!wrapper || wrapper === document.documentElement) wrapper = window;\n        if (typeof duration === \"number\" && typeof easing !== \"function\") easing = $8ecb29f509dc0bd0$var$defaultEasing;\n        else if (typeof easing === \"function\" && typeof duration !== \"number\") duration = 1;\n        this.options = {\n            wrapper: wrapper,\n            content: content,\n            eventsTarget: eventsTarget,\n            smoothWheel: smoothWheel,\n            syncTouch: syncTouch,\n            syncTouchLerp: syncTouchLerp,\n            touchInertiaExponent: touchInertiaExponent,\n            duration: duration,\n            easing: easing,\n            lerp: lerp2,\n            infinite: infinite,\n            gestureOrientation: gestureOrientation,\n            orientation: orientation,\n            touchMultiplier: touchMultiplier,\n            wheelMultiplier: wheelMultiplier,\n            autoResize: autoResize,\n            prevent: prevent,\n            virtualScroll: virtualScroll,\n            overscroll: overscroll,\n            autoRaf: autoRaf,\n            anchors: anchors,\n            autoToggle: autoToggle,\n            allowNestedScroll: allowNestedScroll,\n            naiveDimensions: naiveDimensions,\n            stopInertiaOnNavigate: stopInertiaOnNavigate\n        };\n        this.dimensions = new $8ecb29f509dc0bd0$var$Dimensions(wrapper, content, {\n            autoResize: autoResize\n        });\n        this.updateClassName();\n        this.targetScroll = this.animatedScroll = this.actualScroll;\n        this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        if (this.options.anchors || this.options.stopInertiaOnNavigate) this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n        this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n        this.virtualScroll = new $8ecb29f509dc0bd0$var$VirtualScroll(eventsTarget, {\n            touchMultiplier: touchMultiplier,\n            wheelMultiplier: wheelMultiplier\n        });\n        this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n        if (this.options.autoToggle) {\n            this.checkOverflow();\n            this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n                passive: true\n            });\n        }\n        if (this.options.autoRaf) this._rafId = requestAnimationFrame(this.raf);\n    }\n    /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */ destroy() {\n        this.emitter.destroy();\n        this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n        if (this.options.anchors || this.options.stopInertiaOnNavigate) this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n        this.virtualScroll.destroy();\n        this.dimensions.destroy();\n        this.cleanUpClassName();\n        if (this._rafId) cancelAnimationFrame(this._rafId);\n    }\n    on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    off(event, callback) {\n        return this.emitter.off(event, callback);\n    }\n    onScrollEnd = (e)=>{\n        if (!(e instanceof CustomEvent)) {\n            if (this.isScrolling === \"smooth\" || this.isScrolling === false) e.stopPropagation();\n        }\n    };\n    dispatchScrollendEvent = ()=>{\n        this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n            bubbles: this.options.wrapper === window,\n            // cancelable: false,\n            detail: {\n                lenisScrollEnd: true\n            }\n        }));\n    };\n    get overflow() {\n        const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n        return getComputedStyle(this.rootElement)[property];\n    }\n    checkOverflow() {\n        if ([\n            \"hidden\",\n            \"clip\"\n        ].includes(this.overflow)) this.internalStop();\n        else this.internalStart();\n    }\n    onTransitionEnd = (event)=>{\n        if (event.propertyName.includes(\"overflow\")) this.checkOverflow();\n    };\n    setScroll(scroll) {\n        if (this.isHorizontal) this.options.wrapper.scrollTo({\n            left: scroll,\n            behavior: \"instant\"\n        });\n        else this.options.wrapper.scrollTo({\n            top: scroll,\n            behavior: \"instant\"\n        });\n    }\n    onClick = (event)=>{\n        const path = event.composedPath();\n        const anchorElements = path.filter((node)=>node instanceof HTMLAnchorElement && node.getAttribute(\"href\"));\n        if (this.options.anchors) {\n            const anchor = anchorElements.find((node)=>node.getAttribute(\"href\")?.includes(\"#\"));\n            if (anchor) {\n                const href = anchor.getAttribute(\"href\");\n                if (href) {\n                    const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n                    const target = `#${href.split(\"#\")[1]}`;\n                    this.scrollTo(target, options);\n                }\n            }\n        }\n        if (this.options.stopInertiaOnNavigate) {\n            const internalLink = anchorElements.find((node)=>node.host === window.location.host);\n            if (internalLink) this.reset();\n        }\n    };\n    onPointerDown = (event)=>{\n        if (event.button === 1) this.reset();\n    };\n    onVirtualScroll = (data)=>{\n        if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n        const { deltaX: deltaX, deltaY: deltaY, event: event } = data;\n        this.emitter.emit(\"virtual-scroll\", {\n            deltaX: deltaX,\n            deltaY: deltaY,\n            event: event\n        });\n        if (event.ctrlKey) return;\n        if (event.lenisStopPropagation) return;\n        const isTouch = event.type.includes(\"touch\");\n        const isWheel = event.type.includes(\"wheel\");\n        this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n        const isClickOrTap = deltaX === 0 && deltaY === 0;\n        const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n        if (isTapToStop) {\n            this.reset();\n            return;\n        }\n        const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n        if (isClickOrTap || isUnknownGesture) return;\n        let composedPath = event.composedPath();\n        composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n        const prevent = this.options.prevent;\n        if (!!composedPath.find((node)=>node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, {\n                deltaX: deltaX,\n                deltaY: deltaY\n            })))) return;\n        if (this.isStopped || this.isLocked) {\n            if (event.cancelable) event.preventDefault();\n            return;\n        }\n        const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n        if (!isSmooth) {\n            this.isScrolling = \"native\";\n            this.animate.stop();\n            event.lenisStopPropagation = true;\n            return;\n        }\n        let delta = deltaY;\n        if (this.options.gestureOrientation === \"both\") delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n        else if (this.options.gestureOrientation === \"horizontal\") delta = deltaX;\n        if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) event.lenisStopPropagation = true;\n        if (event.cancelable) event.preventDefault();\n        const isSyncTouch = isTouch && this.options.syncTouch;\n        const isTouchEnd = isTouch && event.type === \"touchend\";\n        const hasTouchInertia = isTouchEnd;\n        if (hasTouchInertia) delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n        this.scrollTo(this.targetScroll + delta, {\n            programmatic: false,\n            ...isSyncTouch ? {\n                lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n            } : {\n                lerp: this.options.lerp,\n                duration: this.options.duration,\n                easing: this.options.easing\n            }\n        });\n    };\n    /**\n   * Force lenis to recalculate the dimensions\n   */ resize() {\n        this.dimensions.resize();\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.emit();\n    }\n    emit() {\n        this.emitter.emit(\"scroll\", this);\n    }\n    onNativeScroll = ()=>{\n        if (this._resetVelocityTimeout !== null) {\n            clearTimeout(this._resetVelocityTimeout);\n            this._resetVelocityTimeout = null;\n        }\n        if (this._preventNextNativeScrollEvent) {\n            this._preventNextNativeScrollEvent = false;\n            return;\n        }\n        if (this.isScrolling === false || this.isScrolling === \"native\") {\n            const lastScroll = this.animatedScroll;\n            this.animatedScroll = this.targetScroll = this.actualScroll;\n            this.lastVelocity = this.velocity;\n            this.velocity = this.animatedScroll - lastScroll;\n            this.direction = Math.sign(this.animatedScroll - lastScroll);\n            if (!this.isStopped) this.isScrolling = \"native\";\n            this.emit();\n            if (this.velocity !== 0) this._resetVelocityTimeout = setTimeout(()=>{\n                this.lastVelocity = this.velocity;\n                this.velocity = 0;\n                this.isScrolling = false;\n                this.emit();\n            }, 400);\n        }\n    };\n    reset() {\n        this.isLocked = false;\n        this.isScrolling = false;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity = 0;\n        this.animate.stop();\n    }\n    /**\n   * Start lenis scroll after it has been stopped\n   */ start() {\n        if (!this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.removeProperty(\"overflow\");\n            return;\n        }\n        this.internalStart();\n    }\n    internalStart() {\n        if (!this.isStopped) return;\n        this.reset();\n        this.isStopped = false;\n        this.emit();\n    }\n    /**\n   * Stop lenis scroll\n   */ stop() {\n        if (this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.setProperty(\"overflow\", \"clip\");\n            return;\n        }\n        this.internalStop();\n    }\n    internalStop() {\n        if (this.isStopped) return;\n        this.reset();\n        this.isStopped = true;\n        this.emit();\n    }\n    /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */ raf = (time)=>{\n        const deltaTime = time - (this.time || time);\n        this.time = time;\n        this.animate.advance(deltaTime * 1e-3);\n        if (this.options.autoRaf) this._rafId = requestAnimationFrame(this.raf);\n    };\n    /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */ scrollTo(target, { offset: offset = 0, immediate: immediate = false, lock: lock = false, programmatic: programmatic = true, // called from outside of the class\n    lerp: lerp2 = programmatic ? this.options.lerp : void 0, duration: duration = programmatic ? this.options.duration : void 0, easing: easing = programmatic ? this.options.easing : void 0, onStart: onStart, onComplete: onComplete, force: force = false, userData: // scroll even if stopped\n    userData } = {}) {\n        if ((this.isStopped || this.isLocked) && !force) return;\n        if (typeof target === \"string\" && [\n            \"top\",\n            \"left\",\n            \"start\",\n            \"#\"\n        ].includes(target)) target = 0;\n        else if (typeof target === \"string\" && [\n            \"bottom\",\n            \"right\",\n            \"end\"\n        ].includes(target)) target = this.limit;\n        else {\n            let node;\n            if (typeof target === \"string\") {\n                node = document.querySelector(target);\n                if (!node) {\n                    if (target === \"#top\") target = 0;\n                    else console.warn(\"Lenis: Target not found\", target);\n                }\n            } else if (target instanceof HTMLElement && target?.nodeType) node = target;\n            if (node) {\n                if (this.options.wrapper !== window) {\n                    const wrapperRect = this.rootElement.getBoundingClientRect();\n                    offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n                }\n                const rect = node.getBoundingClientRect();\n                target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n            }\n        }\n        if (typeof target !== \"number\") return;\n        target += offset;\n        target = Math.round(target);\n        if (this.options.infinite) {\n            if (programmatic) {\n                this.targetScroll = this.animatedScroll = this.scroll;\n                const distance = target - this.animatedScroll;\n                if (distance > this.limit / 2) target = target - this.limit;\n                else if (distance < -this.limit / 2) target = target + this.limit;\n            }\n        } else target = $8ecb29f509dc0bd0$var$clamp(0, target, this.limit);\n        if (target === this.targetScroll) {\n            onStart?.(this);\n            onComplete?.(this);\n            return;\n        }\n        this.userData = userData ?? {};\n        if (immediate) {\n            this.animatedScroll = this.targetScroll = target;\n            this.setScroll(this.scroll);\n            this.reset();\n            this.preventNextNativeScrollEvent();\n            this.emit();\n            onComplete?.(this);\n            this.userData = {};\n            requestAnimationFrame(()=>{\n                this.dispatchScrollendEvent();\n            });\n            return;\n        }\n        if (!programmatic) this.targetScroll = target;\n        if (typeof duration === \"number\" && typeof easing !== \"function\") easing = $8ecb29f509dc0bd0$var$defaultEasing;\n        else if (typeof easing === \"function\" && typeof duration !== \"number\") duration = 1;\n        this.animate.fromTo(this.animatedScroll, target, {\n            duration: duration,\n            easing: easing,\n            lerp: lerp2,\n            onStart: ()=>{\n                if (lock) this.isLocked = true;\n                this.isScrolling = \"smooth\";\n                onStart?.(this);\n            },\n            onUpdate: (value, completed)=>{\n                this.isScrolling = \"smooth\";\n                this.lastVelocity = this.velocity;\n                this.velocity = value - this.animatedScroll;\n                this.direction = Math.sign(this.velocity);\n                this.animatedScroll = value;\n                this.setScroll(this.scroll);\n                if (programmatic) this.targetScroll = value;\n                if (!completed) this.emit();\n                if (completed) {\n                    this.reset();\n                    this.emit();\n                    onComplete?.(this);\n                    this.userData = {};\n                    requestAnimationFrame(()=>{\n                        this.dispatchScrollendEvent();\n                    });\n                    this.preventNextNativeScrollEvent();\n                }\n            }\n        });\n    }\n    preventNextNativeScrollEvent() {\n        this._preventNextNativeScrollEvent = true;\n        requestAnimationFrame(()=>{\n            this._preventNextNativeScrollEvent = false;\n        });\n    }\n    checkNestedScroll(node, { deltaX: deltaX, deltaY: deltaY }) {\n        const time = Date.now();\n        const cache = node._lenis ??= {};\n        let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n        const gestureOrientation = this.options.gestureOrientation;\n        if (time - (cache.time ?? 0) > 2e3) {\n            cache.time = Date.now();\n            const computedStyle = window.getComputedStyle(node);\n            cache.computedStyle = computedStyle;\n            const overflowXString = computedStyle.overflowX;\n            const overflowYString = computedStyle.overflowY;\n            hasOverflowX = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowXString);\n            hasOverflowY = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowYString);\n            cache.hasOverflowX = hasOverflowX;\n            cache.hasOverflowY = hasOverflowY;\n            if (!hasOverflowX && !hasOverflowY) return false;\n            if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n            if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n            scrollWidth = node.scrollWidth;\n            scrollHeight = node.scrollHeight;\n            clientWidth = node.clientWidth;\n            clientHeight = node.clientHeight;\n            isScrollableX = scrollWidth > clientWidth;\n            isScrollableY = scrollHeight > clientHeight;\n            cache.isScrollableX = isScrollableX;\n            cache.isScrollableY = isScrollableY;\n            cache.scrollWidth = scrollWidth;\n            cache.scrollHeight = scrollHeight;\n            cache.clientWidth = clientWidth;\n            cache.clientHeight = clientHeight;\n        } else {\n            isScrollableX = cache.isScrollableX;\n            isScrollableY = cache.isScrollableY;\n            hasOverflowX = cache.hasOverflowX;\n            hasOverflowY = cache.hasOverflowY;\n            scrollWidth = cache.scrollWidth;\n            scrollHeight = cache.scrollHeight;\n            clientWidth = cache.clientWidth;\n            clientHeight = cache.clientHeight;\n        }\n        if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) return false;\n        if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY)) return false;\n        if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX)) return false;\n        let orientation;\n        if (gestureOrientation === \"horizontal\") orientation = \"x\";\n        else if (gestureOrientation === \"vertical\") orientation = \"y\";\n        else {\n            const isScrollingX = deltaX !== 0;\n            const isScrollingY = deltaY !== 0;\n            if (isScrollingX && hasOverflowX && isScrollableX) orientation = \"x\";\n            if (isScrollingY && hasOverflowY && isScrollableY) orientation = \"y\";\n        }\n        if (!orientation) return false;\n        let scroll, maxScroll, delta, hasOverflow, isScrollable;\n        if (orientation === \"x\") {\n            scroll = node.scrollLeft;\n            maxScroll = scrollWidth - clientWidth;\n            delta = deltaX;\n            hasOverflow = hasOverflowX;\n            isScrollable = isScrollableX;\n        } else if (orientation === \"y\") {\n            scroll = node.scrollTop;\n            maxScroll = scrollHeight - clientHeight;\n            delta = deltaY;\n            hasOverflow = hasOverflowY;\n            isScrollable = isScrollableY;\n        } else return false;\n        const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n        return willScroll && hasOverflow && isScrollable;\n    }\n    /**\n   * The root element on which lenis is instanced\n   */ get rootElement() {\n        return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n    }\n    /**\n   * The limit which is the maximum scroll value\n   */ get limit() {\n        if (this.options.naiveDimensions) {\n            if (this.isHorizontal) return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n            else return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n        } else return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n    /**\n   * Whether or not the scroll is horizontal\n   */ get isHorizontal() {\n        return this.options.orientation === \"horizontal\";\n    }\n    /**\n   * The actual scroll value\n   */ get actualScroll() {\n        const wrapper = this.options.wrapper;\n        return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n    }\n    /**\n   * The current scroll value\n   */ get scroll() {\n        return this.options.infinite ? $8ecb29f509dc0bd0$var$modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n    }\n    /**\n   * The progress of the scroll relative to the limit\n   */ get progress() {\n        return this.limit === 0 ? 1 : this.scroll / this.limit;\n    }\n    /**\n   * Current scroll state\n   */ get isScrolling() {\n        return this._isScrolling;\n    }\n    set isScrolling(value) {\n        if (this._isScrolling !== value) {\n            this._isScrolling = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is stopped\n   */ get isStopped() {\n        return this._isStopped;\n    }\n    set isStopped(value) {\n        if (this._isStopped !== value) {\n            this._isStopped = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is locked\n   */ get isLocked() {\n        return this._isLocked;\n    }\n    set isLocked(value) {\n        if (this._isLocked !== value) {\n            this._isLocked = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is smooth scrolling\n   */ get isSmooth() {\n        return this.isScrolling === \"smooth\";\n    }\n    /**\n   * The class name applied to the wrapper element\n   */ get className() {\n        let className = \"lenis\";\n        if (this.options.autoToggle) className += \" lenis-autoToggle\";\n        if (this.isStopped) className += \" lenis-stopped\";\n        if (this.isLocked) className += \" lenis-locked\";\n        if (this.isScrolling) className += \" lenis-scrolling\";\n        if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n        return className;\n    }\n    updateClassName() {\n        this.cleanUpClassName();\n        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n    }\n    cleanUpClassName() {\n        this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n    }\n};\n\n\nfunction $44dff8ba698aec05$var$e(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for(var s = 0, i = Array(e); s < e; s++)i[s] = t[s];\n    return i;\n}\nfunction $44dff8ba698aec05$var$s(t, s) {\n    var i = \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n    if (i) return (i = i.call(t)).next.bind(i);\n    if (Array.isArray(t) || (i = function(t, s) {\n        if (t) {\n            if (\"string\" == typeof t) return $44dff8ba698aec05$var$e(t, s);\n            var i = ({}).toString.call(t).slice(8, -1);\n            return \"Object\" === i && t.constructor && (i = t.constructor.name), \"Map\" === i || \"Set\" === i ? Array.from(t) : \"Arguments\" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? $44dff8ba698aec05$var$e(t, s) : void 0;\n        }\n    }(t)) || s && t && \"number\" == typeof t.length) {\n        i && (t = i);\n        var n = 0;\n        return function() {\n            return n >= t.length ? {\n                done: !0\n            } : {\n                done: !1,\n                value: t[n++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction $44dff8ba698aec05$var$i() {\n    return $44dff8ba698aec05$var$i = Object.assign ? Object.assign.bind() : function(t) {\n        for(var e = 1; e < arguments.length; e++){\n            var s = arguments[e];\n            for(var i in s)({}).hasOwnProperty.call(s, i) && (t[i] = s[i]);\n        }\n        return t;\n    }, $44dff8ba698aec05$var$i.apply(null, arguments);\n}\nvar $44dff8ba698aec05$var$n = /*#__PURE__*/ function() {\n    function t(t) {\n        var e = t.scrollElements, s = t.rootMargin, i = void 0 === s ? \"-1px -1px -1px -1px\" : s, n = t.root, r = void 0 === n ? null : n, o = t.IORaf;\n        this.scrollElements = void 0, this.rootMargin = void 0, this.root = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = e, this.rootMargin = i, this.root = r, this.IORaf = o, this._init();\n    }\n    var e = t.prototype;\n    return e._init = function() {\n        var t = this;\n        this.observer = new IntersectionObserver(function(e) {\n            e.forEach(function(e) {\n                var s = t.scrollElements.find(function(t) {\n                    return t.$el === e.target;\n                });\n                e.isIntersecting ? (s && (s.isAlreadyIntersected = !0), t._setInview(e)) : s && s.isAlreadyIntersected && t._setOutOfView(e);\n            });\n        }, {\n            root: this.root,\n            rootMargin: this.rootMargin\n        });\n        for(var e, i = $44dff8ba698aec05$var$s(this.scrollElements); !(e = i()).done;)this.observe(e.value.$el);\n    }, e.destroy = function() {\n        this.observer.disconnect();\n    }, e.observe = function(t) {\n        t && this.observer.observe(t);\n    }, e.unobserve = function(t) {\n        t && this.observer.unobserve(t);\n    }, e._setInview = function(t) {\n        var e = this.scrollElements.find(function(e) {\n            return e.$el === t.target;\n        });\n        this.IORaf && (null == e || e.setInteractivityOn()), !this.IORaf && (null == e || e.setInview());\n    }, e._setOutOfView = function(t) {\n        var e = this.scrollElements.find(function(e) {\n            return e.$el === t.target;\n        });\n        this.IORaf && (null == e || e.setInteractivityOff()), !this.IORaf && (null == e || e.setOutOfView()), null != e && e.attributes.scrollRepeat || this.IORaf || this.unobserve(t.target);\n    }, t;\n}();\nfunction $44dff8ba698aec05$var$r(t, e, s, i, n) {\n    return s + ((n - t) / (e - t) * (i - s) || 0);\n}\nfunction $44dff8ba698aec05$var$o(t, e) {\n    return t.reduce(function(t, s) {\n        return Math.abs(s - e) < Math.abs(t - e) ? s : t;\n    });\n}\nvar $44dff8ba698aec05$var$l = \"--progress\", $44dff8ba698aec05$var$a = /*#__PURE__*/ function() {\n    function t(t) {\n        var e, s, i, n, r, o = this, l = t.$el, a = t.id, c = t.subscribeElementUpdateFn, h = t.unsubscribeElementUpdateFn, u = t.needRaf, d = t.scrollOrientation, f = t.lenisInstance;\n        this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.lenisInstance = void 0, this.getWindowSize = void 0, this.getMetricsStart = void 0, this.getMetricsSize = void 0, this.startPositionHandlers = {\n            start: function(t, e, s) {\n                return t - e + s;\n            },\n            middle: function(t, e, s, i) {\n                return t - e + s + .5 * i;\n            },\n            end: function(t, e, s, i) {\n                return t - e + s + i;\n            },\n            fold: function() {\n                return 0;\n            }\n        }, this.endPositionHandlers = {\n            start: function(t, e) {\n                return t - e;\n            },\n            middle: function(t, e, s) {\n                return t - e + .5 * s;\n            },\n            end: function(t, e, s) {\n                return t - e + s;\n            }\n        }, this.$el = l, this.id = a, this.needRaf = u, this.scrollOrientation = d, this.lenisInstance = f, this.subscribeElementUpdateFn = c, this.unsubscribeElementUpdateFn = h, this.attributes = {\n            scrollClass: null != (e = this.$el.dataset.scrollClass) ? e : \"is-inview\",\n            scrollOffset: null != (s = this.$el.dataset.scrollOffset) ? s : \"0,0\",\n            scrollPosition: null != (i = this.$el.dataset.scrollPosition) ? i : \"start,end\",\n            scrollCssProgress: void 0 !== this.$el.dataset.scrollCssProgress,\n            scrollEventProgress: null != (n = this.$el.dataset.scrollEventProgress) ? n : null,\n            scrollSpeed: void 0 !== this.$el.dataset.scrollSpeed ? parseFloat(this.$el.dataset.scrollSpeed) : null,\n            scrollRepeat: void 0 !== this.$el.dataset.scrollRepeat,\n            scrollCall: null != (r = this.$el.dataset.scrollCall) ? r : null,\n            scrollIgnoreFold: void 0 !== this.$el.dataset.scrollIgnoreFold,\n            scrollEnableTouchSpeed: void 0 !== this.$el.dataset.scrollEnableTouchSpeed\n        }, this.intersection = {\n            start: 0,\n            end: 0\n        }, this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {}\n        }, this.currentScroll = this.lenisInstance.scroll, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.isInview = !1, this.isInteractive = !1, this.isAlreadyIntersected = !1, this.isInFold = !1, this.isFirstResize = !0, this.getWindowSize = \"vertical\" === this.scrollOrientation ? function() {\n            return o.lenisInstance.dimensions.height;\n        } : function() {\n            return o.lenisInstance.dimensions.width;\n        }, this.getMetricsStart = \"vertical\" === this.scrollOrientation ? function(t) {\n            return t.top;\n        } : function(t) {\n            return t.left;\n        }, this.getMetricsSize = \"vertical\" === this.scrollOrientation ? function(t) {\n            return t.height;\n        } : function(t) {\n            return t.width;\n        }, this._init();\n    }\n    var e = t.prototype;\n    return e._init = function() {\n        this.needRaf && this._resize();\n    }, e.onResize = function(t) {\n        this.currentScroll = t.currentScroll, this._resize();\n    }, e.onRender = function(t) {\n        var e = t.currentScroll, s = t.smooth, i = this.getWindowSize();\n        if (this.currentScroll = e, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) {\n            if (this.attributes.scrollEnableTouchSpeed || s) {\n                if (this.isInFold) {\n                    var n = Math.max(0, this.progress);\n                    this.translateValue = n * i * this.attributes.scrollSpeed * -1;\n                } else {\n                    var o = $44dff8ba698aec05$var$r(0, 1, -1, 1, this.progress);\n                    this.translateValue = o * i * this.attributes.scrollSpeed * -1;\n                }\n                this.$el.style.transform = \"vertical\" === this.scrollOrientation ? \"translate3d(0, \" + this.translateValue + \"px, 0)\" : \"translate3d(\" + this.translateValue + \"px, 0, 0)\";\n            } else this.translateValue && (this.$el.style.transform = \"translate3d(0, 0, 0)\"), this.translateValue = 0;\n        }\n    }, e.setInview = function() {\n        if (!this.isInview) {\n            this.isInview = !0, this.$el.classList.add(this.attributes.scrollClass);\n            var t = this._getScrollCallFrom();\n            this.attributes.scrollCall && this._dispatchCall(\"enter\", t);\n        }\n    }, e.setOutOfView = function() {\n        if (this.isInview && this.attributes.scrollRepeat) {\n            this.isInview = !1, this.$el.classList.remove(this.attributes.scrollClass);\n            var t = this._getScrollCallFrom();\n            this.attributes.scrollCall && this._dispatchCall(\"leave\", t);\n        }\n    }, e.setInteractivityOn = function() {\n        this.isInteractive || (this.isInteractive = !0, this.subscribeElementUpdateFn(this));\n    }, e.setInteractivityOff = function() {\n        this.isInteractive && (this.isInteractive = !1, this.unsubscribeElementUpdateFn(this), null !== this.lastProgress && this._computeProgress($44dff8ba698aec05$var$o([\n            0,\n            1\n        ], this.lastProgress)));\n    }, e._resize = function() {\n        this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = !1, this.isInFold && this.setInview());\n    }, e._computeMetrics = function() {\n        var t = this.getWindowSize(), e = this.getMetricsStart(this.metrics.bcr), s = this.getMetricsSize(this.metrics.bcr);\n        this.metrics.offsetStart = this.currentScroll + e - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + s, this.isInFold = this.metrics.offsetStart < t && !this.attributes.scrollIgnoreFold;\n    }, e._computeIntersection = function() {\n        var t, e, s, i, n, r, o, l, a = this.getWindowSize(), c = this.getMetricsSize(this.metrics.bcr), h = this.attributes.scrollOffset.split(\",\"), u = null != (t = null == (e = h[0]) ? void 0 : e.trim()) ? t : \"0\", d = null != (s = null == (i = h[1]) ? void 0 : i.trim()) ? s : \"0\", f = this.attributes.scrollPosition.split(\",\"), v = null != (n = null == (r = f[0]) ? void 0 : r.trim()) ? n : \"start\", m = null != (o = null == (l = f[1]) ? void 0 : l.trim()) ? o : \"end\", g = u.includes(\"%\") ? a * parseInt(u.replace(\"%\", \"\").trim()) * .01 : parseInt(u), p = d.includes(\"%\") ? a * parseInt(d.replace(\"%\", \"\").trim()) * .01 : parseInt(d);\n        this.isInFold && (v = \"fold\");\n        var b = this.startPositionHandlers[v];\n        this.intersection.start = b ? b(this.metrics.offsetStart, a, g, c) : this.metrics.offsetStart - a + g;\n        var I = this.endPositionHandlers[m];\n        if (this.intersection.end = I ? I(this.metrics.offsetStart, p, c) : this.metrics.offsetStart - p + c, this.intersection.end <= this.intersection.start) switch(m){\n            case \"start\":\n            default:\n                this.intersection.end = this.intersection.start + 1;\n                break;\n            case \"middle\":\n                this.intersection.end = this.intersection.start + .5 * c;\n                break;\n            case \"end\":\n                this.intersection.end = this.intersection.start + c;\n        }\n    }, e._computeProgress = function(t) {\n        var e, s = null != t ? t : (e = $44dff8ba698aec05$var$r(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : e > 1 ? 1 : e;\n        this.progress = s, s !== this.lastProgress && (this.lastProgress = s, this.attributes.scrollCssProgress && this._setCssProgress(s), this.attributes.scrollEventProgress && this._setCustomEventProgress(s), s > 0 && s < 1 && this.setInview(), 0 === s && this.setOutOfView(), 1 === s && this.setOutOfView());\n    }, e._setCssProgress = function(t) {\n        void 0 === t && (t = 0), this.$el.style.setProperty($44dff8ba698aec05$var$l, t.toString());\n    }, e._setCustomEventProgress = function(t) {\n        void 0 === t && (t = 0);\n        var e = this.attributes.scrollEventProgress;\n        if (e) {\n            var s = new CustomEvent(e, {\n                detail: {\n                    target: this.$el,\n                    progress: t\n                }\n            });\n            window.dispatchEvent(s);\n        }\n    }, e._getScrollCallFrom = function() {\n        var t = $44dff8ba698aec05$var$o([\n            this.intersection.start,\n            this.intersection.end\n        ], this.currentScroll);\n        return this.intersection.start === t ? \"start\" : \"end\";\n    }, e.destroy = function() {\n        this.attributes.scrollCssProgress && this.$el.style.removeProperty($44dff8ba698aec05$var$l), this.attributes.scrollSpeed && this.$el.style.removeProperty(\"transform\"), this.isInview && this.attributes.scrollClass && this.$el.classList.remove(this.attributes.scrollClass);\n    }, e._dispatchCall = function(t, e) {\n        var s = this.attributes.scrollCall;\n        if (s) {\n            var i = new CustomEvent(s, {\n                detail: {\n                    target: this.$el,\n                    way: t,\n                    from: e\n                }\n            });\n            window.dispatchEvent(i);\n        }\n    }, t;\n}(), $44dff8ba698aec05$var$c = [\n    \"scrollOffset\",\n    \"scrollPosition\",\n    \"scrollCssProgress\",\n    \"scrollEventProgress\",\n    \"scrollSpeed\"\n], $44dff8ba698aec05$var$h = /*#__PURE__*/ function() {\n    function t(t) {\n        var e = t.$el, s = t.triggerRootMargin, i = t.rafRootMargin, n = t.scrollOrientation, r = t.lenisInstance;\n        this.$scrollContainer = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, this.lenisInstance = void 0, e ? (this.$scrollContainer = e, this.lenisInstance = r, this.scrollOrientation = n, this.triggerRootMargin = null != s ? s : \"-1px -1px -1px -1px\", this.rafRootMargin = null != i ? i : \"100% 100% 100% 100%\", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error(\"Please provide a DOM Element as scrollContainer\");\n    }\n    var e = t.prototype;\n    return e._init = function() {\n        var t = this.$scrollContainer.querySelectorAll(\"[data-scroll]\"), e = this.toElementArray(t);\n        this._subscribeScrollElements(e);\n        var s = this.lenisInstance.options.wrapper === window ? null : this.lenisInstance.options.wrapper;\n        this.IOTriggerInstance = new $44dff8ba698aec05$var$n({\n            scrollElements: [].concat(this.triggeredScrollElements),\n            root: s,\n            rootMargin: this.triggerRootMargin,\n            IORaf: !1\n        }), this.IORafInstance = new $44dff8ba698aec05$var$n({\n            scrollElements: [].concat(this.RAFScrollElements),\n            root: s,\n            rootMargin: this.rafRootMargin,\n            IORaf: !0\n        });\n    }, e.destroy = function() {\n        this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements();\n    }, e.onResize = function(t) {\n        for(var e, i = t.currentScroll, n = $44dff8ba698aec05$var$s(this.RAFScrollElements); !(e = n()).done;)e.value.onResize({\n            currentScroll: i\n        });\n    }, e.onRender = function(t) {\n        for(var e, i = t.currentScroll, n = t.smooth, r = $44dff8ba698aec05$var$s(this.scrollElementsToUpdate); !(e = r()).done;)e.value.onRender({\n            currentScroll: i,\n            smooth: n\n        });\n    }, e.removeScrollElements = function(t) {\n        var e = this, s = t.querySelectorAll(\"[data-scroll]\");\n        if (s.length) {\n            for(var i = new Set(Array.from(s)), n = 0; n < this.triggeredScrollElements.length; n++){\n                var r = this.triggeredScrollElements[n];\n                i.has(r.$el) && (this.IOTriggerInstance.unobserve(r.$el), this.triggeredScrollElements.splice(n, 1));\n            }\n            for(var o = 0; o < this.RAFScrollElements.length; o++){\n                var l = this.RAFScrollElements[o];\n                i.has(l.$el) && (this.IORafInstance.unobserve(l.$el), this.RAFScrollElements.splice(o, 1));\n            }\n            s.forEach(function(t) {\n                var s = e.scrollElementsToUpdate.find(function(e) {\n                    return e.$el === t;\n                }), i = e.scrollElements.find(function(e) {\n                    return e.$el === t;\n                });\n                s && e._unsubscribeElementUpdate(s), i && (e.scrollElements = e.scrollElements.filter(function(t) {\n                    return t.id != i.id;\n                }));\n            });\n        }\n    }, e.addScrollElements = function(t) {\n        var e = t.querySelectorAll(\"[data-scroll]\"), s = [];\n        this.scrollElements.forEach(function(t) {\n            s.push(t.id);\n        });\n        var i = Math.max.apply(Math, s.concat([\n            0\n        ])) + 1, n = this.toElementArray(e);\n        this._subscribeScrollElements(n, i, !0);\n    }, e._subscribeScrollElements = function(t, e, s) {\n        void 0 === e && (e = 0), void 0 === s && (s = !1);\n        for(var i = 0; i < t.length; i++){\n            var n = t[i], r = this._checkRafNeeded(n), o = new $44dff8ba698aec05$var$a({\n                $el: n,\n                id: e + i,\n                scrollOrientation: this.scrollOrientation,\n                lenisInstance: this.lenisInstance,\n                subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),\n                needRaf: r\n            });\n            this.scrollElements.push(o), r ? (this.RAFScrollElements.push(o), s && (this.IORafInstance.scrollElements.push(o), this.IORafInstance.observe(o.$el))) : (this.triggeredScrollElements.push(o), s && (this.IOTriggerInstance.scrollElements.push(o), this.IOTriggerInstance.observe(o.$el)));\n        }\n    }, e._unsubscribeAllScrollElements = function() {\n        for(var t, e = $44dff8ba698aec05$var$s(this.scrollElements); !(t = e()).done;)t.value.destroy();\n        this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = [];\n    }, e._subscribeElementUpdate = function(t) {\n        this.scrollElementsToUpdate.push(t);\n    }, e._unsubscribeElementUpdate = function(t) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(function(e) {\n            return e.id != t.id;\n        });\n    }, e.toElementArray = function(t) {\n        return Array.from(t);\n    }, e._checkRafNeeded = function(t) {\n        var e = [].concat($44dff8ba698aec05$var$c), i = function(t) {\n            e = e.filter(function(e) {\n                return e !== t;\n            });\n        };\n        if (t.dataset.scrollOffset) {\n            if (\"0,0\" !== t.dataset.scrollOffset.split(\",\").map(function(t) {\n                return t.replace(\"%\", \"\").trim();\n            }).join(\",\")) return !0;\n            i(\"scrollOffset\");\n        } else i(\"scrollOffset\");\n        if (t.dataset.scrollPosition) {\n            if (\"top,bottom\" !== t.dataset.scrollPosition.trim()) return !0;\n            i(\"scrollPosition\");\n        } else i(\"scrollPosition\");\n        if (t.dataset.scrollSpeed && !isNaN(parseFloat(t.dataset.scrollSpeed))) return !0;\n        i(\"scrollSpeed\");\n        for(var n, r = $44dff8ba698aec05$var$s(e); !(n = r()).done;)if (n.value in t.dataset) return !0;\n        return !1;\n    }, t;\n}(), $44dff8ba698aec05$export$2e2bcd8739ae039 = /*#__PURE__*/ function() {\n    function e(t) {\n        var e = void 0 === t ? {} : t, s = e.lenisOptions, i = void 0 === s ? {} : s, n = e.triggerRootMargin, r = e.rafRootMargin, o = e.autoStart, l = void 0 === o || o, a = e.scrollCallback, c = void 0 === a ? function() {} : a, h = e.initCustomTicker, u = e.destroyCustomTicker;\n        this.rafPlaying = void 0, this.lenisInstance = null, this.coreInstance = null, this.lenisOptions = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoStart = void 0, this.isTouchDevice = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0, this._originalOnContentResize = void 0, this._originalOnWrapperResize = void 0, window.locomotiveScrollVersion = \"5.0.0\", Object.assign(this, {\n            lenisOptions: i,\n            triggerRootMargin: n,\n            rafRootMargin: r,\n            autoStart: l,\n            scrollCallback: c,\n            initCustomTicker: h,\n            destroyCustomTicker: u\n        }), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = !1, this.isTouchDevice = \"ontouchstart\" in window || navigator.maxTouchPoints > 0, this._init();\n    }\n    var s = e.prototype;\n    return s._init = function() {\n        var e = this;\n        this.lenisInstance = new (0, $8ecb29f509dc0bd0$export$2e2bcd8739ae039)($44dff8ba698aec05$var$i({}, this.lenisOptions)), this.scrollCallback && this.lenisInstance.on(\"scroll\", this.scrollCallback), document.documentElement.setAttribute(\"data-scroll-orientation\", this.lenisInstance.options.orientation), requestAnimationFrame(function() {\n            e.coreInstance = new $44dff8ba698aec05$var$h({\n                $el: e.lenisInstance.rootElement,\n                triggerRootMargin: e.triggerRootMargin,\n                rafRootMargin: e.rafRootMargin,\n                scrollOrientation: e.lenisInstance.options.orientation,\n                lenisInstance: e.lenisInstance\n            }), e._bindEvents(), e.initCustomTicker && !e.destroyCustomTicker ? console.warn(\"initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.\") : !e.initCustomTicker && e.destroyCustomTicker && console.warn(\"destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.\"), e.autoStart && e.start();\n        });\n    }, s.destroy = function() {\n        var t, e = this;\n        this.stop(), this._unbindEvents(), null == (t = this.lenisInstance) || t.destroy(), requestAnimationFrame(function() {\n            var t;\n            null == (t = e.coreInstance) || t.destroy();\n        });\n    }, s._bindEvents = function() {\n        var t = this;\n        this._bindScrollToEvents(), this.lenisInstance && (this._originalOnContentResize = this.lenisInstance.dimensions.onContentResize.bind(this.lenisInstance.dimensions), this._originalOnWrapperResize = this.lenisInstance.dimensions.onWrapperResize.bind(this.lenisInstance.dimensions), this.lenisInstance.dimensions.onContentResize = function() {\n            null == t._originalOnContentResize || t._originalOnContentResize(), t._onResizeBind();\n        }, this.lenisInstance.dimensions.onWrapperResize = function() {\n            null == t._originalOnWrapperResize || t._originalOnWrapperResize(), t._onResizeBind();\n        });\n    }, s._unbindEvents = function() {\n        this._unbindScrollToEvents(), this.lenisInstance && (this._originalOnContentResize && (this.lenisInstance.dimensions.onContentResize = this._originalOnContentResize), this._originalOnWrapperResize && (this.lenisInstance.dimensions.onWrapperResize = this._originalOnWrapperResize));\n    }, s._bindScrollToEvents = function(t) {\n        var e, s = this, i = t || (null == (e = this.lenisInstance) ? void 0 : e.rootElement), n = null == i ? void 0 : i.querySelectorAll(\"[data-scroll-to]\");\n        (null == n ? void 0 : n.length) && n.forEach(function(t) {\n            t.addEventListener(\"click\", s._onScrollToBind, !1);\n        });\n    }, s._unbindScrollToEvents = function(t) {\n        var e, s = this, i = t || (null == (e = this.lenisInstance) ? void 0 : e.rootElement), n = null == i ? void 0 : i.querySelectorAll(\"[data-scroll-to]\");\n        (null == n ? void 0 : n.length) && n.forEach(function(t) {\n            t.removeEventListener(\"click\", s._onScrollToBind, !1);\n        });\n    }, s._onResize = function() {\n        var t, e, s;\n        null == (t = this.coreInstance) || t.onResize({\n            currentScroll: null != (e = null == (s = this.lenisInstance) ? void 0 : s.scroll) ? e : 0,\n            smooth: !this.isTouchDevice\n        });\n    }, s._onRender = function() {\n        var t, e, s, i;\n        null == (t = this.lenisInstance) || t.raf(Date.now()), null == (e = this.coreInstance) || e.onRender({\n            currentScroll: null != (s = null == (i = this.lenisInstance) ? void 0 : i.scroll) ? s : 0,\n            smooth: !this.isTouchDevice\n        });\n    }, s._onScrollTo = function(t) {\n        var e, s;\n        t.preventDefault();\n        var i = null != (e = t.currentTarget) ? e : null;\n        if (i) {\n            var n = i.getAttribute(\"data-scroll-to-href\") || i.getAttribute(\"href\"), r = i.getAttribute(\"data-scroll-to-offset\") || 0, o = i.getAttribute(\"data-scroll-to-duration\") || (null == (s = this.lenisInstance) ? void 0 : s.options.duration);\n            n && this.scrollTo(n, {\n                offset: \"string\" == typeof r ? parseInt(r) : r,\n                duration: \"string\" == typeof o ? parseInt(o) : o\n            });\n        }\n    }, s.start = function() {\n        var t;\n        this.rafPlaying || (null == (t = this.lenisInstance) || t.start(), this.rafPlaying = !0, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf());\n    }, s.stop = function() {\n        var t;\n        this.rafPlaying && (null == (t = this.lenisInstance) || t.stop(), this.rafPlaying = !1, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance));\n    }, s.removeScrollElements = function(t) {\n        var e;\n        t ? (this._unbindScrollToEvents(t), null == (e = this.coreInstance) || e.removeScrollElements(t)) : console.error(\"Please provide a DOM Element as $oldContainer\");\n    }, s.addScrollElements = function(t) {\n        var e, s = this;\n        t ? (null == (e = this.coreInstance) || e.addScrollElements(t), requestAnimationFrame(function() {\n            s._bindScrollToEvents(t);\n        })) : console.error(\"Please provide a DOM Element as $newContainer\");\n    }, s.resize = function() {\n        this._onResizeBind();\n    }, s.scrollTo = function(t, e) {\n        var s;\n        null == (s = this.lenisInstance) || s.scrollTo(t, {\n            offset: null == e ? void 0 : e.offset,\n            lerp: null == e ? void 0 : e.lerp,\n            duration: null == e ? void 0 : e.duration,\n            immediate: null == e ? void 0 : e.immediate,\n            lock: null == e ? void 0 : e.lock,\n            force: null == e ? void 0 : e.force,\n            easing: null == e ? void 0 : e.easing,\n            onComplete: null == e ? void 0 : e.onComplete\n        });\n    }, s._raf = function() {\n        var t = this;\n        this._onRenderBind(), this.rafInstance = requestAnimationFrame(function() {\n            return t._raf();\n        });\n    }, e;\n}();\n\n\n\nlet $d2967b03e75792e9$var$scroll = null;\nwindow.addEventListener('load', ()=>{\n    const container = document.querySelector('[data-scroll-container]');\n    if (!container) return;\n    $d2967b03e75792e9$var$scroll = new (0, $44dff8ba698aec05$export$2e2bcd8739ae039)({\n        el: container,\n        smooth: true\n    });\n    window.addEventListener('resize', ()=>{\n        if ($d2967b03e75792e9$var$scroll) $d2967b03e75792e9$var$scroll.update();\n    });\n});\n\n\n//# sourceMappingURL=bads.6c37a0a2.js.map\n","// import 'locomotive-scroll/dist/locomotive-scroll.css';\r\n// import LocomotiveScroll from 'locomotive-scroll';\r\n// const scroll = new LocomotiveScroll();\r\n// console.log('scroll initialized');\r\n\r\n\r\nimport LocomotiveScroll from 'locomotive-scroll';\r\nimport 'locomotive-scroll/dist/locomotive-scroll.css';\r\n\r\nlet scroll = null;\r\n\r\nwindow.addEventListener('load', () => {\r\n  const container = document.querySelector('[data-scroll-container]');\r\n  if (!container) return;\r\n\r\n  scroll = new LocomotiveScroll({\r\n    el: container,\r\n    smooth: true\r\n  });\r\n\r\n  window.addEventListener('resize', () => {\r\n    if (scroll) {\r\n      scroll.update();\r\n    }\r\n  });\r\n});","import t from\"lenis\";function e(t,e){(null==e||e>t.length)&&(e=t.length);for(var s=0,i=Array(e);s<e;s++)i[s]=t[s];return i}function s(t,s){var i=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(i)return(i=i.call(t)).next.bind(i);if(Array.isArray(t)||(i=function(t,s){if(t){if(\"string\"==typeof t)return e(t,s);var i={}.toString.call(t).slice(8,-1);return\"Object\"===i&&t.constructor&&(i=t.constructor.name),\"Map\"===i||\"Set\"===i?Array.from(t):\"Arguments\"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?e(t,s):void 0}}(t))||s&&t&&\"number\"==typeof t.length){i&&(t=i);var n=0;return function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}function i(){return i=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var i in s)({}).hasOwnProperty.call(s,i)&&(t[i]=s[i])}return t},i.apply(null,arguments)}var n=/*#__PURE__*/function(){function t(t){var e=t.scrollElements,s=t.rootMargin,i=void 0===s?\"-1px -1px -1px -1px\":s,n=t.root,r=void 0===n?null:n,o=t.IORaf;this.scrollElements=void 0,this.rootMargin=void 0,this.root=void 0,this.IORaf=void 0,this.observer=void 0,this.scrollElements=e,this.rootMargin=i,this.root=r,this.IORaf=o,this._init()}var e=t.prototype;return e._init=function(){var t=this;this.observer=new IntersectionObserver(function(e){e.forEach(function(e){var s=t.scrollElements.find(function(t){return t.$el===e.target});e.isIntersecting?(s&&(s.isAlreadyIntersected=!0),t._setInview(e)):s&&s.isAlreadyIntersected&&t._setOutOfView(e)})},{root:this.root,rootMargin:this.rootMargin});for(var e,i=s(this.scrollElements);!(e=i()).done;)this.observe(e.value.$el)},e.destroy=function(){this.observer.disconnect()},e.observe=function(t){t&&this.observer.observe(t)},e.unobserve=function(t){t&&this.observer.unobserve(t)},e._setInview=function(t){var e=this.scrollElements.find(function(e){return e.$el===t.target});this.IORaf&&(null==e||e.setInteractivityOn()),!this.IORaf&&(null==e||e.setInview())},e._setOutOfView=function(t){var e=this.scrollElements.find(function(e){return e.$el===t.target});this.IORaf&&(null==e||e.setInteractivityOff()),!this.IORaf&&(null==e||e.setOutOfView()),null!=e&&e.attributes.scrollRepeat||this.IORaf||this.unobserve(t.target)},t}();function r(t,e,s,i,n){return s+((n-t)/(e-t)*(i-s)||0)}function o(t,e){return t.reduce(function(t,s){return Math.abs(s-e)<Math.abs(t-e)?s:t})}var l=\"--progress\",a=/*#__PURE__*/function(){function t(t){var e,s,i,n,r,o=this,l=t.$el,a=t.id,c=t.subscribeElementUpdateFn,h=t.unsubscribeElementUpdateFn,u=t.needRaf,d=t.scrollOrientation,f=t.lenisInstance;this.$el=void 0,this.id=void 0,this.needRaf=void 0,this.attributes=void 0,this.scrollOrientation=void 0,this.isAlreadyIntersected=void 0,this.intersection=void 0,this.metrics=void 0,this.currentScroll=void 0,this.translateValue=void 0,this.progress=void 0,this.lastProgress=void 0,this.isInview=void 0,this.isInteractive=void 0,this.isInFold=void 0,this.isFirstResize=void 0,this.subscribeElementUpdateFn=void 0,this.unsubscribeElementUpdateFn=void 0,this.lenisInstance=void 0,this.getWindowSize=void 0,this.getMetricsStart=void 0,this.getMetricsSize=void 0,this.startPositionHandlers={start:function(t,e,s){return t-e+s},middle:function(t,e,s,i){return t-e+s+.5*i},end:function(t,e,s,i){return t-e+s+i},fold:function(){return 0}},this.endPositionHandlers={start:function(t,e){return t-e},middle:function(t,e,s){return t-e+.5*s},end:function(t,e,s){return t-e+s}},this.$el=l,this.id=a,this.needRaf=u,this.scrollOrientation=d,this.lenisInstance=f,this.subscribeElementUpdateFn=c,this.unsubscribeElementUpdateFn=h,this.attributes={scrollClass:null!=(e=this.$el.dataset.scrollClass)?e:\"is-inview\",scrollOffset:null!=(s=this.$el.dataset.scrollOffset)?s:\"0,0\",scrollPosition:null!=(i=this.$el.dataset.scrollPosition)?i:\"start,end\",scrollCssProgress:void 0!==this.$el.dataset.scrollCssProgress,scrollEventProgress:null!=(n=this.$el.dataset.scrollEventProgress)?n:null,scrollSpeed:void 0!==this.$el.dataset.scrollSpeed?parseFloat(this.$el.dataset.scrollSpeed):null,scrollRepeat:void 0!==this.$el.dataset.scrollRepeat,scrollCall:null!=(r=this.$el.dataset.scrollCall)?r:null,scrollIgnoreFold:void 0!==this.$el.dataset.scrollIgnoreFold,scrollEnableTouchSpeed:void 0!==this.$el.dataset.scrollEnableTouchSpeed},this.intersection={start:0,end:0},this.metrics={offsetStart:0,offsetEnd:0,bcr:{}},this.currentScroll=this.lenisInstance.scroll,this.translateValue=0,this.progress=0,this.lastProgress=null,this.isInview=!1,this.isInteractive=!1,this.isAlreadyIntersected=!1,this.isInFold=!1,this.isFirstResize=!0,this.getWindowSize=\"vertical\"===this.scrollOrientation?function(){return o.lenisInstance.dimensions.height}:function(){return o.lenisInstance.dimensions.width},this.getMetricsStart=\"vertical\"===this.scrollOrientation?function(t){return t.top}:function(t){return t.left},this.getMetricsSize=\"vertical\"===this.scrollOrientation?function(t){return t.height}:function(t){return t.width},this._init()}var e=t.prototype;return e._init=function(){this.needRaf&&this._resize()},e.onResize=function(t){this.currentScroll=t.currentScroll,this._resize()},e.onRender=function(t){var e=t.currentScroll,s=t.smooth,i=this.getWindowSize();if(this.currentScroll=e,this._computeProgress(),this.attributes.scrollSpeed&&!isNaN(this.attributes.scrollSpeed))if(this.attributes.scrollEnableTouchSpeed||s){if(this.isInFold){var n=Math.max(0,this.progress);this.translateValue=n*i*this.attributes.scrollSpeed*-1}else{var o=r(0,1,-1,1,this.progress);this.translateValue=o*i*this.attributes.scrollSpeed*-1}this.$el.style.transform=\"vertical\"===this.scrollOrientation?\"translate3d(0, \"+this.translateValue+\"px, 0)\":\"translate3d(\"+this.translateValue+\"px, 0, 0)\"}else this.translateValue&&(this.$el.style.transform=\"translate3d(0, 0, 0)\"),this.translateValue=0},e.setInview=function(){if(!this.isInview){this.isInview=!0,this.$el.classList.add(this.attributes.scrollClass);var t=this._getScrollCallFrom();this.attributes.scrollCall&&this._dispatchCall(\"enter\",t)}},e.setOutOfView=function(){if(this.isInview&&this.attributes.scrollRepeat){this.isInview=!1,this.$el.classList.remove(this.attributes.scrollClass);var t=this._getScrollCallFrom();this.attributes.scrollCall&&this._dispatchCall(\"leave\",t)}},e.setInteractivityOn=function(){this.isInteractive||(this.isInteractive=!0,this.subscribeElementUpdateFn(this))},e.setInteractivityOff=function(){this.isInteractive&&(this.isInteractive=!1,this.unsubscribeElementUpdateFn(this),null!==this.lastProgress&&this._computeProgress(o([0,1],this.lastProgress)))},e._resize=function(){this.metrics.bcr=this.$el.getBoundingClientRect(),this._computeMetrics(),this._computeIntersection(),this.isFirstResize&&(this.isFirstResize=!1,this.isInFold&&this.setInview())},e._computeMetrics=function(){var t=this.getWindowSize(),e=this.getMetricsStart(this.metrics.bcr),s=this.getMetricsSize(this.metrics.bcr);this.metrics.offsetStart=this.currentScroll+e-this.translateValue,this.metrics.offsetEnd=this.metrics.offsetStart+s,this.isInFold=this.metrics.offsetStart<t&&!this.attributes.scrollIgnoreFold},e._computeIntersection=function(){var t,e,s,i,n,r,o,l,a=this.getWindowSize(),c=this.getMetricsSize(this.metrics.bcr),h=this.attributes.scrollOffset.split(\",\"),u=null!=(t=null==(e=h[0])?void 0:e.trim())?t:\"0\",d=null!=(s=null==(i=h[1])?void 0:i.trim())?s:\"0\",f=this.attributes.scrollPosition.split(\",\"),v=null!=(n=null==(r=f[0])?void 0:r.trim())?n:\"start\",m=null!=(o=null==(l=f[1])?void 0:l.trim())?o:\"end\",g=u.includes(\"%\")?a*parseInt(u.replace(\"%\",\"\").trim())*.01:parseInt(u),p=d.includes(\"%\")?a*parseInt(d.replace(\"%\",\"\").trim())*.01:parseInt(d);this.isInFold&&(v=\"fold\");var b=this.startPositionHandlers[v];this.intersection.start=b?b(this.metrics.offsetStart,a,g,c):this.metrics.offsetStart-a+g;var I=this.endPositionHandlers[m];if(this.intersection.end=I?I(this.metrics.offsetStart,p,c):this.metrics.offsetStart-p+c,this.intersection.end<=this.intersection.start)switch(m){case\"start\":default:this.intersection.end=this.intersection.start+1;break;case\"middle\":this.intersection.end=this.intersection.start+.5*c;break;case\"end\":this.intersection.end=this.intersection.start+c}},e._computeProgress=function(t){var e,s=null!=t?t:(e=r(this.intersection.start,this.intersection.end,0,1,this.currentScroll))<0?0:e>1?1:e;this.progress=s,s!==this.lastProgress&&(this.lastProgress=s,this.attributes.scrollCssProgress&&this._setCssProgress(s),this.attributes.scrollEventProgress&&this._setCustomEventProgress(s),s>0&&s<1&&this.setInview(),0===s&&this.setOutOfView(),1===s&&this.setOutOfView())},e._setCssProgress=function(t){void 0===t&&(t=0),this.$el.style.setProperty(l,t.toString())},e._setCustomEventProgress=function(t){void 0===t&&(t=0);var e=this.attributes.scrollEventProgress;if(e){var s=new CustomEvent(e,{detail:{target:this.$el,progress:t}});window.dispatchEvent(s)}},e._getScrollCallFrom=function(){var t=o([this.intersection.start,this.intersection.end],this.currentScroll);return this.intersection.start===t?\"start\":\"end\"},e.destroy=function(){this.attributes.scrollCssProgress&&this.$el.style.removeProperty(l),this.attributes.scrollSpeed&&this.$el.style.removeProperty(\"transform\"),this.isInview&&this.attributes.scrollClass&&this.$el.classList.remove(this.attributes.scrollClass)},e._dispatchCall=function(t,e){var s=this.attributes.scrollCall;if(s){var i=new CustomEvent(s,{detail:{target:this.$el,way:t,from:e}});window.dispatchEvent(i)}},t}(),c=[\"scrollOffset\",\"scrollPosition\",\"scrollCssProgress\",\"scrollEventProgress\",\"scrollSpeed\"],h=/*#__PURE__*/function(){function t(t){var e=t.$el,s=t.triggerRootMargin,i=t.rafRootMargin,n=t.scrollOrientation,r=t.lenisInstance;this.$scrollContainer=void 0,this.triggerRootMargin=void 0,this.rafRootMargin=void 0,this.scrollElements=void 0,this.triggeredScrollElements=void 0,this.RAFScrollElements=void 0,this.scrollElementsToUpdate=void 0,this.IOTriggerInstance=void 0,this.IORafInstance=void 0,this.scrollOrientation=void 0,this.lenisInstance=void 0,e?(this.$scrollContainer=e,this.lenisInstance=r,this.scrollOrientation=n,this.triggerRootMargin=null!=s?s:\"-1px -1px -1px -1px\",this.rafRootMargin=null!=i?i:\"100% 100% 100% 100%\",this.scrollElements=[],this.triggeredScrollElements=[],this.RAFScrollElements=[],this.scrollElementsToUpdate=[],this._init()):console.error(\"Please provide a DOM Element as scrollContainer\")}var e=t.prototype;return e._init=function(){var t=this.$scrollContainer.querySelectorAll(\"[data-scroll]\"),e=this.toElementArray(t);this._subscribeScrollElements(e);var s=this.lenisInstance.options.wrapper===window?null:this.lenisInstance.options.wrapper;this.IOTriggerInstance=new n({scrollElements:[].concat(this.triggeredScrollElements),root:s,rootMargin:this.triggerRootMargin,IORaf:!1}),this.IORafInstance=new n({scrollElements:[].concat(this.RAFScrollElements),root:s,rootMargin:this.rafRootMargin,IORaf:!0})},e.destroy=function(){this.IOTriggerInstance.destroy(),this.IORafInstance.destroy(),this._unsubscribeAllScrollElements()},e.onResize=function(t){for(var e,i=t.currentScroll,n=s(this.RAFScrollElements);!(e=n()).done;)e.value.onResize({currentScroll:i})},e.onRender=function(t){for(var e,i=t.currentScroll,n=t.smooth,r=s(this.scrollElementsToUpdate);!(e=r()).done;)e.value.onRender({currentScroll:i,smooth:n})},e.removeScrollElements=function(t){var e=this,s=t.querySelectorAll(\"[data-scroll]\");if(s.length){for(var i=new Set(Array.from(s)),n=0;n<this.triggeredScrollElements.length;n++){var r=this.triggeredScrollElements[n];i.has(r.$el)&&(this.IOTriggerInstance.unobserve(r.$el),this.triggeredScrollElements.splice(n,1))}for(var o=0;o<this.RAFScrollElements.length;o++){var l=this.RAFScrollElements[o];i.has(l.$el)&&(this.IORafInstance.unobserve(l.$el),this.RAFScrollElements.splice(o,1))}s.forEach(function(t){var s=e.scrollElementsToUpdate.find(function(e){return e.$el===t}),i=e.scrollElements.find(function(e){return e.$el===t});s&&e._unsubscribeElementUpdate(s),i&&(e.scrollElements=e.scrollElements.filter(function(t){return t.id!=i.id}))})}},e.addScrollElements=function(t){var e=t.querySelectorAll(\"[data-scroll]\"),s=[];this.scrollElements.forEach(function(t){s.push(t.id)});var i=Math.max.apply(Math,s.concat([0]))+1,n=this.toElementArray(e);this._subscribeScrollElements(n,i,!0)},e._subscribeScrollElements=function(t,e,s){void 0===e&&(e=0),void 0===s&&(s=!1);for(var i=0;i<t.length;i++){var n=t[i],r=this._checkRafNeeded(n),o=new a({$el:n,id:e+i,scrollOrientation:this.scrollOrientation,lenisInstance:this.lenisInstance,subscribeElementUpdateFn:this._subscribeElementUpdate.bind(this),unsubscribeElementUpdateFn:this._unsubscribeElementUpdate.bind(this),needRaf:r});this.scrollElements.push(o),r?(this.RAFScrollElements.push(o),s&&(this.IORafInstance.scrollElements.push(o),this.IORafInstance.observe(o.$el))):(this.triggeredScrollElements.push(o),s&&(this.IOTriggerInstance.scrollElements.push(o),this.IOTriggerInstance.observe(o.$el)))}},e._unsubscribeAllScrollElements=function(){for(var t,e=s(this.scrollElements);!(t=e()).done;)t.value.destroy();this.scrollElements=[],this.RAFScrollElements=[],this.triggeredScrollElements=[],this.scrollElementsToUpdate=[]},e._subscribeElementUpdate=function(t){this.scrollElementsToUpdate.push(t)},e._unsubscribeElementUpdate=function(t){this.scrollElementsToUpdate=this.scrollElementsToUpdate.filter(function(e){return e.id!=t.id})},e.toElementArray=function(t){return Array.from(t)},e._checkRafNeeded=function(t){var e=[].concat(c),i=function(t){e=e.filter(function(e){return e!==t})};if(t.dataset.scrollOffset){if(\"0,0\"!==t.dataset.scrollOffset.split(\",\").map(function(t){return t.replace(\"%\",\"\").trim()}).join(\",\"))return!0;i(\"scrollOffset\")}else i(\"scrollOffset\");if(t.dataset.scrollPosition){if(\"top,bottom\"!==t.dataset.scrollPosition.trim())return!0;i(\"scrollPosition\")}else i(\"scrollPosition\");if(t.dataset.scrollSpeed&&!isNaN(parseFloat(t.dataset.scrollSpeed)))return!0;i(\"scrollSpeed\");for(var n,r=s(e);!(n=r()).done;)if(n.value in t.dataset)return!0;return!1},t}(),u=/*#__PURE__*/function(){function e(t){var e=void 0===t?{}:t,s=e.lenisOptions,i=void 0===s?{}:s,n=e.triggerRootMargin,r=e.rafRootMargin,o=e.autoStart,l=void 0===o||o,a=e.scrollCallback,c=void 0===a?function(){}:a,h=e.initCustomTicker,u=e.destroyCustomTicker;this.rafPlaying=void 0,this.lenisInstance=null,this.coreInstance=null,this.lenisOptions=void 0,this.triggerRootMargin=void 0,this.rafRootMargin=void 0,this.rafInstance=void 0,this.autoStart=void 0,this.isTouchDevice=void 0,this.initCustomTicker=void 0,this.destroyCustomTicker=void 0,this._onRenderBind=void 0,this._onResizeBind=void 0,this._onScrollToBind=void 0,this._originalOnContentResize=void 0,this._originalOnWrapperResize=void 0,window.locomotiveScrollVersion=\"5.0.0\",Object.assign(this,{lenisOptions:i,triggerRootMargin:n,rafRootMargin:r,autoStart:l,scrollCallback:c,initCustomTicker:h,destroyCustomTicker:u}),this._onRenderBind=this._onRender.bind(this),this._onScrollToBind=this._onScrollTo.bind(this),this._onResizeBind=this._onResize.bind(this),this.rafPlaying=!1,this.isTouchDevice=\"ontouchstart\"in window||navigator.maxTouchPoints>0,this._init()}var s=e.prototype;return s._init=function(){var e=this;this.lenisInstance=new t(i({},this.lenisOptions)),this.scrollCallback&&this.lenisInstance.on(\"scroll\",this.scrollCallback),document.documentElement.setAttribute(\"data-scroll-orientation\",this.lenisInstance.options.orientation),requestAnimationFrame(function(){e.coreInstance=new h({$el:e.lenisInstance.rootElement,triggerRootMargin:e.triggerRootMargin,rafRootMargin:e.rafRootMargin,scrollOrientation:e.lenisInstance.options.orientation,lenisInstance:e.lenisInstance}),e._bindEvents(),e.initCustomTicker&&!e.destroyCustomTicker?console.warn(\"initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.\"):!e.initCustomTicker&&e.destroyCustomTicker&&console.warn(\"destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.\"),e.autoStart&&e.start()})},s.destroy=function(){var t,e=this;this.stop(),this._unbindEvents(),null==(t=this.lenisInstance)||t.destroy(),requestAnimationFrame(function(){var t;null==(t=e.coreInstance)||t.destroy()})},s._bindEvents=function(){var t=this;this._bindScrollToEvents(),this.lenisInstance&&(this._originalOnContentResize=this.lenisInstance.dimensions.onContentResize.bind(this.lenisInstance.dimensions),this._originalOnWrapperResize=this.lenisInstance.dimensions.onWrapperResize.bind(this.lenisInstance.dimensions),this.lenisInstance.dimensions.onContentResize=function(){null==t._originalOnContentResize||t._originalOnContentResize(),t._onResizeBind()},this.lenisInstance.dimensions.onWrapperResize=function(){null==t._originalOnWrapperResize||t._originalOnWrapperResize(),t._onResizeBind()})},s._unbindEvents=function(){this._unbindScrollToEvents(),this.lenisInstance&&(this._originalOnContentResize&&(this.lenisInstance.dimensions.onContentResize=this._originalOnContentResize),this._originalOnWrapperResize&&(this.lenisInstance.dimensions.onWrapperResize=this._originalOnWrapperResize))},s._bindScrollToEvents=function(t){var e,s=this,i=t||(null==(e=this.lenisInstance)?void 0:e.rootElement),n=null==i?void 0:i.querySelectorAll(\"[data-scroll-to]\");(null==n?void 0:n.length)&&n.forEach(function(t){t.addEventListener(\"click\",s._onScrollToBind,!1)})},s._unbindScrollToEvents=function(t){var e,s=this,i=t||(null==(e=this.lenisInstance)?void 0:e.rootElement),n=null==i?void 0:i.querySelectorAll(\"[data-scroll-to]\");(null==n?void 0:n.length)&&n.forEach(function(t){t.removeEventListener(\"click\",s._onScrollToBind,!1)})},s._onResize=function(){var t,e,s;null==(t=this.coreInstance)||t.onResize({currentScroll:null!=(e=null==(s=this.lenisInstance)?void 0:s.scroll)?e:0,smooth:!this.isTouchDevice})},s._onRender=function(){var t,e,s,i;null==(t=this.lenisInstance)||t.raf(Date.now()),null==(e=this.coreInstance)||e.onRender({currentScroll:null!=(s=null==(i=this.lenisInstance)?void 0:i.scroll)?s:0,smooth:!this.isTouchDevice})},s._onScrollTo=function(t){var e,s;t.preventDefault();var i=null!=(e=t.currentTarget)?e:null;if(i){var n=i.getAttribute(\"data-scroll-to-href\")||i.getAttribute(\"href\"),r=i.getAttribute(\"data-scroll-to-offset\")||0,o=i.getAttribute(\"data-scroll-to-duration\")||(null==(s=this.lenisInstance)?void 0:s.options.duration);n&&this.scrollTo(n,{offset:\"string\"==typeof r?parseInt(r):r,duration:\"string\"==typeof o?parseInt(o):o})}},s.start=function(){var t;this.rafPlaying||(null==(t=this.lenisInstance)||t.start(),this.rafPlaying=!0,this.initCustomTicker?this.initCustomTicker(this._onRenderBind):this._raf())},s.stop=function(){var t;this.rafPlaying&&(null==(t=this.lenisInstance)||t.stop(),this.rafPlaying=!1,this.destroyCustomTicker?this.destroyCustomTicker(this._onRenderBind):this.rafInstance&&cancelAnimationFrame(this.rafInstance))},s.removeScrollElements=function(t){var e;t?(this._unbindScrollToEvents(t),null==(e=this.coreInstance)||e.removeScrollElements(t)):console.error(\"Please provide a DOM Element as $oldContainer\")},s.addScrollElements=function(t){var e,s=this;t?(null==(e=this.coreInstance)||e.addScrollElements(t),requestAnimationFrame(function(){s._bindScrollToEvents(t)})):console.error(\"Please provide a DOM Element as $newContainer\")},s.resize=function(){this._onResizeBind()},s.scrollTo=function(t,e){var s;null==(s=this.lenisInstance)||s.scrollTo(t,{offset:null==e?void 0:e.offset,lerp:null==e?void 0:e.lerp,duration:null==e?void 0:e.duration,immediate:null==e?void 0:e.immediate,lock:null==e?void 0:e.lock,force:null==e?void 0:e.force,easing:null==e?void 0:e.easing,onComplete:null==e?void 0:e.onComplete})},s._raf=function(){var t=this;this._onRenderBind(),this.rafInstance=requestAnimationFrame(function(){return t._raf()})},e}();export{u as default};\n//# sourceMappingURL=locomotive-scroll.mjs.map\n","/**\n * Intersection Observer\n *\n * Detecting visibility of an element in the viewport.\n *\n * Features functions to:\n *\n * - Trigger inview/outOfView callbacks\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\n */\n\nimport type { IIOOptions } from '../types';\nimport ScrollElement from './ScrollElement';\n\nexport default class IO {\n    public scrollElements: ScrollElement[];\n    private rootMargin: string;\n    private root: HTMLElement | null;\n    private IORaf: boolean;\n    private observer!: IntersectionObserver;\n\n    constructor({\n        scrollElements,\n        rootMargin = '-1px -1px -1px -1px',\n        root = null,\n        IORaf,\n    }: IIOOptions) {\n        // Parameters\n        this.scrollElements = scrollElements;\n        this.rootMargin = rootMargin;\n        this.root = root;\n        this.IORaf = IORaf;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Intersection Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Options\n        const observerOptions = {\n            root: this.root,\n            rootMargin: this.rootMargin,\n        };\n\n        // Callback\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\n            entries.forEach((entry) => {\n                const $targetItem: ScrollElement | undefined =\n                    this.scrollElements.find(\n                        (item) => item.$el === entry.target\n                    );\n\n                if (entry.isIntersecting) {\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\n                    this._setInview(entry);\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n                    this._setOutOfView(entry);\n                }\n            });\n        };\n\n        // Instance\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\n\n        // Observe each default elements\n        for (const scrollElement of this.scrollElements) {\n            const $scrollElement = scrollElement.$el;\n            this.observe($scrollElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Intersection Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n\n    /**\n     * Subscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\n     */\n    public observe($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.observe($scrollElement);\n    }\n\n    /**\n     * Unsubscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\n     */\n    public unobserve($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.unobserve($scrollElement);\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger inview callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setInview(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOn();\n        !this.IORaf && scrollElement?.setInview();\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger out of view callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setOutOfView(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOff();\n        !this.IORaf && scrollElement?.setOutOfView();\n\n        // Unobserve if element doesn't have repeat attribute\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\n            this.unobserve(entry.target as HTMLElement);\n        }\n    }\n}\n","// https://greensock.com/docs/v3/GSAP/gsap.utils\n\n/**\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\n *\n * @param {number} min   - Minimum value expected.\n * @param {number} max   - Maximum value expected.\n * @param {number} value - Current value.\n *\n * @returns {number} - Clamped value.\n */\nexport function clamp(min: number, max: number, value: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\n *\n * @param {number} inMin  - Current minimum value.\n * @param {number} inMax  - Current maximum value.\n * @param {number} outMin - Maximum value expected.\n * @param {number} outMax - Maximum value expected.\n * @param {number} value  - Current value.\n *\n * @returns {number} - New value that should be between minimum value expected and maximum value.\n */\nexport function mapRange(\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n    value: number\n): number {\n    const inRange = inMax - inMin;\n    const outRange = outMax - outMin;\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\n}\n\n/**\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\n *\n * @param {number} min   - Current minimum value.\n * @param {number} max   - Current maximum value.\n * @param {number} value - Current value.\n *\n * @returns {number} - New value that should be between 0 and 1.\n */\nexport function normalize(min: number, max: number, value: number): number {\n    return mapRange(min, max, 0, 1, value);\n}\n\n/**\n * Get closest number from an array.\n *\n * @param {number[]} array  - Numbers array.\n * @param {number}   target - Reference value.\n *\n * @returns {number} - Closest number.\n */\nexport function closestNumber(array: number[], target: number): number {\n    return array.reduce((prev, curr) => {\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n    });\n}\n","/**\n * Scroll Element\n *\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\n *\n * Features functions to:\n *\n * - scrollClass - Add a custom class when the element is intersected by the offset\n * - scrollOffset - Determine offsets to intersect the element\n * - scrollPosition - Determine the element positions to consider an element as intersected.\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\n * - scrollEventProgress - Send scroll progress to custom event listeners.\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\n * - scrollCall - Call a custom event when the element is intersected\n */\n\nimport type {\n    IScrollElementOptions,\n    IScrollElementAttributes,\n    IScrollElementIntersection,\n    IScrollElementMetrics,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\n\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\n\nexport default class ScrollElement {\n    public $el: HTMLElement;\n    public id: number;\n    public needRaf: boolean;\n    public attributes: IScrollElementAttributes;\n    public scrollOrientation: scrollOrientation;\n    public isAlreadyIntersected: boolean;\n\n    private intersection: IScrollElementIntersection;\n    private metrics: IScrollElementMetrics;\n    private currentScroll: number;\n    private translateValue: number;\n    private progress: number;\n    private lastProgress: number | null;\n    private isInview: boolean;\n    private isInteractive: boolean;\n    private isInFold: boolean;\n    private isFirstResize: boolean;\n\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private lenisInstance: any;\n\n    // Cached functions to avoid orientation checks every frame\n    private getWindowSize: () => number;\n    private getMetricsStart: (bcr: DOMRect) => number;\n    private getMetricsSize: (bcr: DOMRect) => number;\n\n    // Position handlers for intersection.start (includes wSize)\n    private readonly startPositionHandlers: Record<string, (offsetStart: number, wSize: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, wSize, viewport) => offsetStart - wSize + viewport,\n        'middle': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size * 0.5,\n        'end': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size,\n        'fold': () => 0,\n    };\n\n    // Position handlers for intersection.end (DOES NOT include wSize - critical difference)\n    private readonly endPositionHandlers: Record<string, (offsetStart: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, viewport) => offsetStart - viewport,\n        'middle': (offsetStart, viewport, size) => offsetStart - viewport + size * 0.5,\n        'end': (offsetStart, viewport, size) => offsetStart - viewport + size,\n    };\n\n    constructor({\n        $el,\n        id,\n        subscribeElementUpdateFn,\n        unsubscribeElementUpdateFn,\n        needRaf,\n        scrollOrientation,\n        lenisInstance,\n    }: IScrollElementOptions) {\n        // Scroll DOM element\n        this.$el = $el;\n        // Unique ID\n        this.id = id;\n        // RAF option\n        this.needRaf = needRaf;\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n        // Parent's callbacks\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n\n        // Attributes\n        this.attributes = {\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] !== undefined,\n            scrollEventProgress:\n                this.$el.dataset['scrollEventProgress'] ?? null,\n            scrollSpeed:\n                this.$el.dataset['scrollSpeed'] !== undefined\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\n                    : null,\n            scrollRepeat: this.$el.dataset['scrollRepeat'] !== undefined,\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] !== undefined,\n            scrollEnableTouchSpeed:\n                this.$el.dataset['scrollEnableTouchSpeed'] !== undefined,\n        };\n\n        // Limits\n        this.intersection = {\n            start: 0,\n            end: 0,\n        };\n\n        // Metrics\n        this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {} as DOMRect,\n        };\n\n        // Scroll Values\n        this.currentScroll = this.lenisInstance.scroll;\n\n        // Parallax\n        this.translateValue = 0;\n\n        // Progress\n        this.progress = 0;\n        this.lastProgress = null;\n\n        // Inview\n        this.isInview = false;\n        this.isInteractive = false;\n        this.isAlreadyIntersected = false;\n        this.isInFold = false;\n        this.isFirstResize = true;\n\n        // Cache orientation-dependent functions to avoid repeated conditionals\n        this.getWindowSize = this.scrollOrientation === 'vertical'\n            ? () => this.lenisInstance.dimensions.height\n            : () => this.lenisInstance.dimensions.width;\n\n        this.getMetricsStart = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.top\n            : (bcr: DOMRect) => bcr.left;\n\n        this.getMetricsSize = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.height\n            : (bcr: DOMRect) => bcr.width;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize progress tracking.\n     *\n     * @private\n     */\n    private _init() {\n        if (!this.needRaf) {\n            return;\n        }\n\n        // First resize to compute all values\n        this._resize();\n    }\n\n    /**\n     * Callback - Resize callback\n     */\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        this.currentScroll = currentScroll;\n        this._resize();\n    }\n\n    /**\n     * Callback - RAF callback\n     */\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        const wSize = this.getWindowSize();\n        this.currentScroll = currentScroll;\n        this._computeProgress();\n\n        // Parallax\n        if (\n            this.attributes.scrollSpeed &&\n            !isNaN(this.attributes.scrollSpeed)\n        ) {\n            // if touch detected or smooth disabled\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n                if (this.translateValue) {\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\n                }\n                this.translateValue = 0;\n\n            // if mousewheel or smooth enabled\n            } else {\n                // Check fold condition\n                if (this.isInFold) {\n                    const progress = Math.max(0, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                } else {\n                    const progress = mapRange(0, 1, -1, 1, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                }\n\n                this.$el.style.transform =\n                    this.scrollOrientation === 'vertical'\n                        ? `translate3d(0, ${this.translateValue}px, 0)`\n                        : `translate3d(${this.translateValue}px, 0, 0)`;\n            }\n        }\n    }\n\n    /**\n     * Inview callback\n     */\n    public setInview() {\n        if (this.isInview) {\n            return;\n        }\n\n        this.isInview = true;\n        this.$el.classList.add(this.attributes.scrollClass);\n\n        const way = 'enter';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Out of view callback\n     */\n    public setOutOfView() {\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\n            return;\n        }\n\n        this.isInview = false;\n        this.$el.classList.remove(this.attributes.scrollClass);\n\n        const way = 'leave';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Switch interactivity on to subscribe the instance to the RAF\n     * and start calculations.\n     */\n    public setInteractivityOn() {\n        if (this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = true;\n        this.subscribeElementUpdateFn(this);\n    }\n\n    /**\n     * Switch interactivity off to unsubscribe the instance to the RAF\n     * and stop calculations.\n     */\n    public setInteractivityOff() {\n        if (!this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = false;\n        this.unsubscribeElementUpdateFn(this);\n\n        // Force progress to progress limit when the element is out\n        this.lastProgress !== null &&\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\n    }\n\n    /**\n     * Resize method that compute the element's values.\n     *\n     * @private\n     */\n    private _resize() {\n        this.metrics.bcr = this.$el.getBoundingClientRect();\n        this._computeMetrics();\n        this._computeIntersection();\n\n        // First resize logic\n        if (this.isFirstResize) {\n            this.isFirstResize = false;\n            // Dispatch default call if the element is in fold.\n            if (this.isInFold) {\n                this.setInview();\n            }\n        }\n    }\n\n    /**\n     * Compute element's offsets and determine if the element is in fold.\n     *\n     * @private\n     */\n    private _computeMetrics() {\n        const wSize = this.getWindowSize();\n        const metricsStart = this.getMetricsStart(this.metrics.bcr);\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        this.metrics.offsetStart =\n            this.currentScroll + metricsStart - this.translateValue;\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n\n        if (\n            this.metrics.offsetStart < wSize &&\n            !this.attributes.scrollIgnoreFold\n        ) {\n            this.isInFold = true;\n        } else {\n            this.isInFold = false;\n        }\n    }\n\n    /**\n     * Compute intersection values depending on the context.\n     * Uses handler-based approach for cleaner, more maintainable code.\n     *\n     * @private\n     */\n    private _computeIntersection() {\n        const wSize = this.getWindowSize();\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        // Parse offset\n        const offset = this.attributes.scrollOffset.split(',');\n        const offsetStart = offset[0]?.trim() ?? '0';\n        const offsetEnd = offset[1]?.trim() ?? '0';\n\n        // Parse positions\n        const scrollPosition = this.attributes.scrollPosition.split(',');\n        let scrollPositionStart = scrollPosition[0]?.trim() ?? 'start';\n        const scrollPositionEnd = scrollPosition[1]?.trim() ?? 'end';\n\n        // Calculate viewport offsets\n        const viewportStart = offsetStart.includes('%')\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\n            : parseInt(offsetStart);\n        const viewportEnd = offsetEnd.includes('%')\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\n            : parseInt(offsetEnd);\n\n        // Fold exception\n        if (this.isInFold) {\n            scrollPositionStart = 'fold';\n        }\n\n        // Calculate intersection.start using handlers\n        const startHandler = this.startPositionHandlers[scrollPositionStart];\n        this.intersection.start = startHandler\n            ? startHandler(this.metrics.offsetStart, wSize, viewportStart, metricsSize)\n            : this.metrics.offsetStart - wSize + viewportStart; // default fallback\n\n        // Calculate intersection.end using handlers\n        const endHandler = this.endPositionHandlers[scrollPositionEnd];\n        this.intersection.end = endHandler\n            ? endHandler(this.metrics.offsetStart, viewportEnd, metricsSize)\n            : this.metrics.offsetStart - viewportEnd + metricsSize; // default fallback\n\n        // Ensure end > start\n        if (this.intersection.end <= this.intersection.start) {\n            switch (scrollPositionEnd) {\n                case 'start':\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n                case 'middle':\n                    this.intersection.end = this.intersection.start + metricsSize * 0.5;\n                    break;\n                case 'end':\n                    this.intersection.end = this.intersection.start + metricsSize;\n                    break;\n                default:\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Compute the scroll progress of the element depending\n     * on its intersection values.\n     *\n     * @private\n     *\n     * @param {number} [forcedProgress] - Value to force progress.\n     */\n    private _computeProgress(forcedProgress?: number) {\n        // Progress\n        const progress =\n            forcedProgress ??\n            clamp(\n                0,\n                1,\n                normalize(\n                    this.intersection.start,\n                    this.intersection.end,\n                    this.currentScroll\n                )\n            );\n\n        this.progress = progress;\n\n        if (progress !== this.lastProgress) {\n            this.lastProgress = progress;\n\n            // Set the element's progress to the css variable\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\n\n            // Set the element's progress to the custom event listeners\n            this.attributes.scrollEventProgress &&\n                this._setCustomEventProgress(progress);\n\n            // Logic to trigger the inview/out of view callbacks\n            progress > 0 && progress < 1 && this.setInview();\n            progress === 0 && this.setOutOfView();\n            progress === 1 && this.setOutOfView();\n        }\n    }\n\n    /**\n     * Set the element's progress to a specific css variable.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCssProgress(currentProgress = 0) {\n        this.$el.style.setProperty(\n            PROGRESS_CSS_VAR,\n            currentProgress.toString()\n        );\n    }\n\n    /**\n     * Set the element's progress to the custom event listeners.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCustomEventProgress(currentProgress = 0) {\n        const customEventName = this.attributes.scrollEventProgress;\n\n        if (!customEventName) return;\n\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                progress: currentProgress,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n\n    /**\n     * Function to get scroll call from.\n     *\n     * @private\n     */\n    _getScrollCallFrom() {\n        const closestIntersectionValue = closestNumber(\n            [this.intersection.start, this.intersection.end],\n            this.currentScroll\n        );\n        return this.intersection.start === closestIntersectionValue\n            ? 'start'\n            : 'end';\n    }\n\n    /**\n     * Lifecyle - Destroy and cleanup the scroll element.\n     *\n     * Removes all CSS modifications and clears references to prevent memory leaks.\n     */\n    public destroy(): void {\n        // Remove CSS variables\n        if (this.attributes.scrollCssProgress) {\n            this.$el.style.removeProperty(PROGRESS_CSS_VAR);\n        }\n\n        // Remove transform if parallax was applied\n        if (this.attributes.scrollSpeed) {\n            this.$el.style.removeProperty('transform');\n        }\n\n        // Remove class if added\n        if (this.isInview && this.attributes.scrollClass) {\n            this.$el.classList.remove(this.attributes.scrollClass);\n        }\n    }\n\n    /**\n     * Function to dispatch a custom event.\n     *\n     * @private\n     *\n     * @param {string} way - Enter or leave.\n     * @param {string} from - Start or end.\n     */\n    _dispatchCall(way: string, from: string) {\n        const customEventName = this.attributes.scrollCall;\n\n        if (!customEventName) return;\n\n        // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                way,\n                from,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n}\n","/**\n * Integrates Lenis with Locomotive's built-in animation system\n */\n\nimport type {\n    CoreOptions,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport IO from './IO';\nimport ScrollElement from './ScrollElement';\n\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = [\n    'scrollOffset',\n    'scrollPosition',\n    'scrollCssProgress',\n    'scrollEventProgress',\n    'scrollSpeed',\n];\n\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\n\n/** Default scroll attribute values */\nconst DEFAULT_SCROLL_OFFSET = '0,0';\nconst DEFAULT_SCROLL_POSITION = 'top,bottom';\n\nexport default class Core {\n    private $scrollContainer!: HTMLElement;\n    private triggerRootMargin!: string;\n    private rafRootMargin!: string;\n    private scrollElements!: ScrollElement[];\n    private triggeredScrollElements!: ScrollElement[];\n    private RAFScrollElements!: ScrollElement[];\n    private scrollElementsToUpdate!: ScrollElement[];\n    private IOTriggerInstance!: IO;\n    private IORafInstance!: IO;\n    private scrollOrientation!: scrollOrientation;\n    private lenisInstance: any;\n\n    constructor({\n        $el,\n        triggerRootMargin,\n        rafRootMargin,\n        scrollOrientation,\n        lenisInstance,\n    }: CoreOptions) {\n        if (!$el) {\n            console.error('Please provide a DOM Element as scrollContainer');\n            return;\n        }\n\n        // Scroll container\n        this.$scrollContainer = $el;\n\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n\n        // IO Margins\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\n\n        // ScrollElements arrays\n        this.scrollElements = [];\n        this.triggeredScrollElements = [];\n        this.RAFScrollElements = [];\n        this.scrollElementsToUpdate = [];\n\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize the core.\n     *\n     * @private\n     */\n    private _init() {\n        const $scrollElements =\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\n\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements($scrollElementsArr);\n\n        // Determine IO root (null for window, wrapper element for custom container)\n        const ioRoot = this.lenisInstance.options.wrapper === window\n            ? null\n            : this.lenisInstance.options.wrapper as HTMLElement;\n\n        // Trigger IO\n        this.IOTriggerInstance = new IO({\n            scrollElements: [...this.triggeredScrollElements],\n            root: ioRoot,\n            rootMargin: this.triggerRootMargin,\n            IORaf: false,\n        });\n\n        // Raf IO\n        this.IORafInstance = new IO({\n            scrollElements: [...this.RAFScrollElements],\n            root: ioRoot,\n            rootMargin: this.rafRootMargin,\n            IORaf: true,\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy core.\n     */\n    public destroy() {\n        this.IOTriggerInstance.destroy();\n        this.IORafInstance.destroy();\n        this._unsubscribeAllScrollElements();\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.RAFScrollElements) {\n            scrollElement.onResize({\n                currentScroll,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Callback - RAF callback.\n     */\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.scrollElementsToUpdate) {\n            scrollElement.onRender({\n                currentScroll,\n                smooth,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Remove items from lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\n     */\n    removeScrollElements($oldContainer: HTMLElement) {\n        const $scrollElementsToRemove =\n            $oldContainer.querySelectorAll('[data-scroll]');\n\n        if (!$scrollElementsToRemove.length) return;\n\n        const $scrollElementsToRemoveSet = new Set(Array.from($scrollElementsToRemove));\n\n        // 1. Remove from IO\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n            const scrollElement = this.triggeredScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\n                this.triggeredScrollElements.splice(index, 1);\n            }\n        }\n\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\n            const scrollElement = this.RAFScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IORafInstance.unobserve(scrollElement.$el);\n                this.RAFScrollElements.splice(index, 1);\n            }\n        }\n\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n        $scrollElementsToRemove.forEach(($scrollElement) => {\n            const targetScrollElementToUpdate =\n                this.scrollElementsToUpdate.find(\n                    (scrollElement) => scrollElement.$el === $scrollElement\n                );\n            const targetScrollElement = this.scrollElements.find(\n                (scrollElement) => scrollElement.$el === $scrollElement\n            );\n\n            if (targetScrollElementToUpdate) {\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n            }\n            if (targetScrollElement) {\n                this.scrollElements = this.scrollElements.filter(\n                    (scrollElementItem) =>\n                        scrollElementItem.id != targetScrollElement.id\n                );\n            }\n        });\n    }\n\n    /**\n     * Add items to lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\n     */\n    addScrollElements($newContainer: HTMLElement) {\n        // 3. Rebuild ScrollElements\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n\n        // 4. Get max scrollElement.id\n        const ids: number[] = [];\n        this.scrollElements.forEach((scrollElement) => {\n            ids.push(scrollElement.id);\n        });\n        const maxID = Math.max(...ids, 0);\n        const fromIndex = maxID + 1;\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements(\n            $scrollElementsArr,\n            fromIndex,\n            true\n        );\n    }\n\n    /**\n     * Create a ScrollElement instance for each elements with\n     * `data-scroll` attribute.\n     *\n     * @private\n     *\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\n     *     to be regarded.\n     */\n    _subscribeScrollElements(\n        $scrollElements: HTMLElement[],\n        fromIndex = 0,\n        toObserve = false\n    ) {\n        // For each scroll element create a ScrollElement instance\n        for (let index = 0; index < $scrollElements.length; index++) {\n            const $scrollElement = $scrollElements[index];\n            const needRaf = this._checkRafNeeded($scrollElement);\n\n            const scrollElementInstance = new ScrollElement({\n                $el: $scrollElement,\n                id: fromIndex + index,\n                scrollOrientation: this.scrollOrientation,\n                lenisInstance: this.lenisInstance,\n                subscribeElementUpdateFn:\n                    this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn:\n                    this._unsubscribeElementUpdate.bind(this),\n                needRaf,\n            });\n\n            // Push to common array\n            this.scrollElements.push(scrollElementInstance);\n\n            // Push to specific array\n            if (needRaf) {\n                this.RAFScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IORafInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IORafInstance.observe(scrollElementInstance.$el);\n                }\n            } else {\n                this.triggeredScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IOTriggerInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear all ScrollElement arrays.\n     *\n     * @private\n     */\n    _unsubscribeAllScrollElements() {\n        // Destroy all scroll elements to clean up CSS and references\n        for (const scrollElement of this.scrollElements) {\n            scrollElement.destroy();\n        }\n\n        this.scrollElements = [];\n        this.RAFScrollElements = [];\n        this.triggeredScrollElements = [];\n        this.scrollElementsToUpdate = [];\n    }\n\n    /**\n     * Subscribe ScrollElement instance that needs to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\n     *     that needs to be updated.\n     */\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate.push(scrollElement);\n    }\n\n    /**\n     * Unscribe ScrollElement instance that doesn't need to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\n     *     out of view now.\n     */\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\n            (scrollElementToUpdate) =>\n                scrollElementToUpdate.id != scrollElement.id\n        );\n    }\n\n    /**\n     * Convert NodeListOf<Element> to HTMLElement array.\n     *\n     * @private\n     *\n     * @param {NodeListOf<Element>} elements - The NodeList to convert.\n     *\n     * @returns {HTMLElement[]}\n     */\n    private toElementArray(elements: NodeListOf<Element>): HTMLElement[] {\n        return Array.from(elements) as HTMLElement[];\n    }\n\n    /**\n     * Check if a DOM Element need a requestAnimationFrame to be used.\n     *\n     * @private\n     *\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\n     *\n     * @returns {boolean}\n     */\n    _checkRafNeeded($scrollElement: HTMLElement) {\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n\n        // Remove utils\n        const removeAttribute = (attributeToRemove: string) => {\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\n                (attribute) => attribute !== attributeToRemove\n            );\n        };\n\n        // 1. Check scroll offset values\n        if ($scrollElement.dataset.scrollOffset) {\n            const value = $scrollElement.dataset.scrollOffset\n                .split(',')\n                .map((test) => test.replace('%', '').trim())\n                .join(',');\n            if (value !== DEFAULT_SCROLL_OFFSET) {\n                return true;\n            } else {\n                removeAttribute('scrollOffset');\n            }\n        } else {\n            removeAttribute('scrollOffset');\n        }\n\n        // 2. Check scroll position values\n        if ($scrollElement.dataset.scrollPosition) {\n            const value = $scrollElement.dataset.scrollPosition.trim();\n            if (value !== DEFAULT_SCROLL_POSITION) {\n                return true;\n            } else {\n                removeAttribute('scrollPosition');\n            }\n        } else {\n            removeAttribute('scrollPosition');\n        }\n\n        // 3. Check scroll speed values\n        if (\n            $scrollElement.dataset.scrollSpeed &&\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\n        ) {\n            return true;\n        } else {\n            removeAttribute('scrollSpeed');\n        }\n\n        // 4. Check others attributes\n        for (const attribute of attributesThatNeedRaf) {\n            if (attribute in $scrollElement.dataset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","import { version } from './package.json'\nimport Lenis from 'lenis';\nimport Core from './core/Core';\nimport type {\n    ILenisScrollToOptions,\n    ILenisScrollValues,\n    ILocomotiveScrollOptions,\n    lenisTargetScrollTo,\n} from './types';\nimport type { LenisOptions } from 'lenis';\n\n/**\n * Locomotive Scroll\n *\n * Detection of elements in viewport & smooth scrolling with parallax.\n *\n * Inspired by\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\n * and built around\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\n */\n\nexport default class LocomotiveScroll {\n    public rafPlaying: boolean;\n    public lenisInstance: Lenis | null = null;\n\n    private coreInstance: Core | null = null;\n\n    private lenisOptions?: LenisOptions;\n    private triggerRootMargin?: string;\n    private rafRootMargin?: string;\n    private rafInstance?: number;\n    private autoStart?: boolean;\n    private isTouchDevice: boolean;\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\n    private initCustomTicker?: (render: () => void) => void;\n    private destroyCustomTicker?: (render: () => void) => void;\n    private _onRenderBind: () => void;\n    private _onResizeBind: () => void;\n    private _onScrollToBind: (event: MouseEvent) => void;\n    private _originalOnContentResize?: () => void;\n    private _originalOnWrapperResize?: () => void;\n\n    constructor({\n        lenisOptions = {},\n        triggerRootMargin,\n        rafRootMargin,\n        autoStart = true,\n        scrollCallback = () => {},\n        initCustomTicker,\n        destroyCustomTicker,\n    }: ILocomotiveScrollOptions = {}) {\n\n        // Set version\n        window.locomotiveScrollVersion = version;\n\n        // Get arguments\n        Object.assign(this, {\n            lenisOptions,\n            triggerRootMargin,\n            rafRootMargin,\n            autoStart,\n            scrollCallback,\n            initCustomTicker,\n            destroyCustomTicker,\n        });\n\n\n        // Binding\n        this._onRenderBind = this._onRender.bind(this);\n        this._onScrollToBind = this._onScrollTo.bind(this);\n        this._onResizeBind = this._onResize.bind(this);\n\n        // Data\n        this.rafPlaying = false;\n\n        // Detect if device has touch capability\n        this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize instance.\n     *\n     * @private\n     */\n    private _init(): void {\n        \n        // Create Lenis instance\n        this.lenisInstance = new Lenis({\n            ...this.lenisOptions\n        });\n\n        // Subscribe to scroll callback if provided\n        if (this.scrollCallback) {\n            this.lenisInstance.on('scroll', this.scrollCallback);\n        }\n\n        // Add scroll direction attribute on body\n        document.documentElement.setAttribute(\n            'data-scroll-orientation',\n            this.lenisInstance.options.orientation\n        );\n\n        requestAnimationFrame(() => {\n            // Create Core Instance\n            // lenisInstance is guaranteed to exist at this point (created above)\n            this.coreInstance = new Core({\n                $el: this.lenisInstance!.rootElement,\n                triggerRootMargin: this.triggerRootMargin,\n                rafRootMargin: this.rafRootMargin,\n                scrollOrientation: this.lenisInstance!.options.orientation,\n                lenisInstance: this.lenisInstance!,\n            });\n\n            // Bind Events\n            this._bindEvents();\n\n            // RAF warning\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\n                console.warn(\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n                console.warn(\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            }\n\n            // Start RAF\n            this.autoStart && this.start();\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy instance.\n     */\n    public destroy(): void {\n        // Stop raf\n        this.stop();\n        // Unbind Events\n        this._unbindEvents();\n        // Destroy Lenis\n        this.lenisInstance?.destroy();\n\n        // Destroy Core after RAF to ensure any pending Intersection Observer callbacks complete\n        // This prevents race conditions when destroy() is called while IO callbacks are queued\n        requestAnimationFrame(() => {\n            this.coreInstance?.destroy();\n        });\n    }\n\n    /**\n     * Events - Subscribe events to listen.\n     */\n    private _bindEvents() {\n        this._bindScrollToEvents();\n\n        // Hook into Lenis dimensions resize callbacks\n        // onContentResize: called when content size changes (images load, dynamic content)\n        // onWrapperResize: called when wrapper size changes (window resize, layout changes)\n        if (this.lenisInstance) {\n            this._originalOnContentResize = this.lenisInstance.dimensions.onContentResize.bind(\n                this.lenisInstance.dimensions\n            );\n            this._originalOnWrapperResize = this.lenisInstance.dimensions.onWrapperResize.bind(\n                this.lenisInstance.dimensions\n            );\n\n            this.lenisInstance.dimensions.onContentResize = () => {\n                this._originalOnContentResize?.();\n                this._onResizeBind();\n            };\n\n            this.lenisInstance.dimensions.onWrapperResize = () => {\n                this._originalOnWrapperResize?.();\n                this._onResizeBind();\n            };\n        }\n    }\n\n    /**\n     * Events - Unsubscribe listened events.\n     */\n    private _unbindEvents() {\n        this._unbindScrollToEvents();\n\n        // Restore original Lenis dimensions resize callbacks\n        if (this.lenisInstance) {\n            if (this._originalOnContentResize) {\n                this.lenisInstance.dimensions.onContentResize = this._originalOnContentResize;\n            }\n            if (this._originalOnWrapperResize) {\n                this.lenisInstance.dimensions.onWrapperResize = this._originalOnWrapperResize;\n            }\n        }\n    }\n\n    /**\n     * Events - Subscribe scrollTo events to listen.\n     */\n    private _bindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el): void => {\n                ($el as HTMLElement).addEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Events - Unsubscribe scrollTo listened events.\n     */\n    private _unbindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el) => {\n                ($el as HTMLElement).removeEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Callback - Resize callback.\n     *\n     * Called synchronously after Lenis updates its dimensions via onContentResize/onWrapperResize.\n     * All dimension values are already up-to-date when this executes.\n     */\n    private _onResize() {\n        this.coreInstance?.onResize({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Render callback.\n     */\n    private _onRender() {\n        this.lenisInstance?.raf(Date.now());\n\n        this.coreInstance?.onRender({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Scroll To callback.\n     */\n    private _onScrollTo(event: MouseEvent) {\n        event.preventDefault();\n        const $target = (event.currentTarget as HTMLElement) ?? null;\n        if (!$target) return;\n        const target =\n            $target.getAttribute('data-scroll-to-href') ||\n            $target.getAttribute('href');\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n        const duration =\n            $target.getAttribute('data-scroll-to-duration') ||\n            this.lenisInstance?.options.duration\n        target &&\n            this.scrollTo(target, {\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\n                duration:\n                    typeof duration === 'string'\n                        ? parseInt(duration)\n                        : duration,\n            });\n    }\n\n    /**\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public start(): void {\n        if (this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis start method\n        this.lenisInstance?.start();\n\n        this.rafPlaying = true;\n        this.initCustomTicker\n            ? this.initCustomTicker(this._onRenderBind)\n            : this._raf();\n    }\n\n    /**\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public stop(): void {\n        if (!this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis stop method\n        this.lenisInstance?.stop();\n\n        this.rafPlaying = false;\n        this.destroyCustomTicker\n            ? this.destroyCustomTicker(this._onRenderBind)\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n    }\n\n    /**\n     * Remove old scroll elements items and rebuild ScrollElements instances.\n     */\n    public removeScrollElements($oldContainer: HTMLElement): void {\n        if (!$oldContainer) {\n            console.error('Please provide a DOM Element as $oldContainer');\n            return;\n        }\n\n        this._unbindScrollToEvents($oldContainer);\n        this.coreInstance?.removeScrollElements($oldContainer);\n    }\n\n    /**\n     * Add new scroll elements items and rebuild ScrollElements instances.\n     */\n    public addScrollElements($newContainer: HTMLElement): void {\n        if (!$newContainer) {\n            console.error('Please provide a DOM Element as $newContainer');\n            return;\n        }\n\n        this.coreInstance?.addScrollElements($newContainer);\n        requestAnimationFrame(() => {\n            this._bindScrollToEvents($newContainer);\n        });\n    }\n\n    /**\n     * Trigger resize callback.\n     */\n    public resize(): void {\n        this._onResizeBind();\n    }\n\n    /**\n     * Trigger scroll to callback.\n     */\n    public scrollTo(\n        target: lenisTargetScrollTo,\n        options?: ILenisScrollToOptions\n    ): void {\n        this.lenisInstance?.scrollTo(target, {\n            offset: options?.offset,\n            lerp: options?.lerp,\n            duration: options?.duration,\n            immediate: options?.immediate,\n            lock: options?.lock,\n            force: options?.force,\n            easing: options?.easing,\n            onComplete: options?.onComplete,\n        });\n    }\n\n    /**\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\n     *\n     * @private\n     *\n     */\n    private _raf() {\n        this._onRenderBind();\n        this.rafInstance = requestAnimationFrame(() => this._raf());\n    }\n}\n\nexport * from './types';\n","// package.json\nvar version = \"1.3.17\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  _rafId = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.checkOverflow();\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  get overflow() {\n    const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n    return getComputedStyle(this.rootElement)[property];\n  }\n  checkOverflow() {\n    if ([\"hidden\", \"clip\"].includes(this.overflow)) {\n      this.internalStop();\n    } else {\n      this.internalStart();\n    }\n  }\n  onTransitionEnd = (event) => {\n    if (event.propertyName.includes(\"overflow\")) {\n      this.checkOverflow();\n    }\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")\n    );\n    if (this.options.anchors) {\n      const anchor = anchorElements.find(\n        (node) => node.getAttribute(\"href\")?.includes(\"#\")\n      );\n      if (anchor) {\n        const href = anchor.getAttribute(\"href\");\n        if (href) {\n          const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n          const target = `#${href.split(\"#\")[1]}`;\n          this.scrollTo(target, options);\n        }\n      }\n    }\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      );\n      if (internalLink) {\n        this.reset();\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd;\n    if (hasTouchInertia) {\n      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    programmatic = true,\n    // called from outside of the class\n    lerp: lerp2 = programmatic ? this.options.lerp : void 0,\n    duration = programmatic ? this.options.duration : void 0,\n    easing = programmatic ? this.options.easing : void 0,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\", \"#\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n        if (!node) {\n          if (target === \"#top\") {\n            target = 0;\n          } else {\n            console.warn(\"Lenis: Target not found\", target);\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ??= {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n//# sourceMappingURL=lenis.mjs.map","{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.17\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:framer\": \"npm version prerelease --preid framer --force --no-git-tag-version\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:dev\": \"npm publish --tag dev\",\n    \"publish:framer\": \"npm publish --tag framer\",\n    \"publish:main\": \"npm publish\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n","/**\n * Clamp a value between a minimum and maximum value\n *\n * @param min Minimum value\n * @param input Value to clamp\n * @param max Maximum value\n * @returns Clamped value\n */\nexport function clamp(min: number, input: number, max: number) {\n  return Math.max(min, Math.min(input, max))\n}\n\n/**\n * Truncate a floating-point number to a specified number of decimal places\n *\n * @param value Value to truncate\n * @param decimals Number of decimal places to truncate to\n * @returns Truncated value\n */\nexport function truncate(value: number, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n/**\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\n *\n * @param x First value\n * @param y Second value\n * @param t Amount to interpolate (0 <= t <= 1)\n * @returns Interpolated value\n */\nexport function lerp(x: number, y: number, t: number) {\n  return (1 - t) * x + t * y\n}\n\n/**\n * Damp a value over time using a damping factor\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\n *\n * @param x Initial value\n * @param y Target value\n * @param lambda Damping factor\n * @param dt Time elapsed since the last update\n * @returns Damped value\n */\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\n}\n\n/**\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n * {@link https://anguscroll.com/just/just-modulo}\n *\n * @param n Dividend\n * @param d Divisor\n * @returns Modulo\n */\nexport function modulo(n: number, d: number) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","export function debounce<CB extends (...args: any[]) => void>(\n  callback: CB,\n  delay: number\n) {\n  let timer: number | undefined\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      timer = undefined\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","import { debounce } from './debounce'\n\n/**\n * Dimensions class to handle the size of the content and wrapper\n *\n * @example\n * const dimensions = new Dimensions(wrapper, content)\n * dimensions.on('resize', (e) => {\n *   console.log(e.width, e.height)\n * })\n */\nexport class Dimensions {\n  width = 0\n  height = 0\n  scrollHeight = 0\n  scrollWidth = 0\n\n  // These are instanciated in the constructor as they need information from the options\n  private debouncedResize?: (...args: unknown[]) => void\n  private wrapperResizeObserver?: ResizeObserver\n  private contentResizeObserver?: ResizeObserver\n\n  constructor(\n    private wrapper: HTMLElement | Window | Element,\n    private content: HTMLElement | Element,\n    { autoResize = true, debounce: debounceValue = 250 } = {}\n  ) {\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue)\n\n      if (this.wrapper instanceof Window) {\n        window.addEventListener('resize', this.debouncedResize, false)\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener('resize', this.debouncedResize, false)\n    }\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight\n      this.scrollWidth = this.content.scrollWidth\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight\n      this.scrollWidth = this.wrapper.scrollWidth\n    }\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","/**\n * Emitter class to handle events\n * @example\n * const emitter = new Emitter()\n * emitter.on('event', (data) => {\n *   console.log(data)\n * })\n * emitter.emit('event', 'data')\n */\nexport class Emitter {\n  private events: Record<\n    string,\n    Array<(...args: unknown[]) => void> | undefined\n  > = {}\n\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event: string, ...args: unknown[]) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args)\n    }\n  }\n\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private _rafId: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = orientation === 'horizontal' ? 'both' : 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.checkOverflow()\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  get overflow() {\n    const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n    return getComputedStyle(this.rootElement)[\n      property as keyof CSSStyleDeclaration\n    ] as string\n  }\n\n  private checkOverflow() {\n    if (['hidden', 'clip'].includes(this.overflow)) {\n      this.internalStop()\n    } else {\n      this.internalStart()\n    }\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      this.checkOverflow()\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n\n    // filter anchor elements (elements with a valid href attribute)\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute('href')\n    ) as HTMLAnchorElement[]\n\n    if (this.options.anchors) {\n      const anchor = anchorElements.find((node) =>\n        node.getAttribute('href')?.includes('#')\n      )\n      if (anchor) {\n        const href = anchor.getAttribute('href')\n\n        if (href) {\n          const options =\n            typeof this.options.anchors === 'object' && this.options.anchors\n              ? this.options.anchors\n              : undefined\n\n          const target = `#${href.split('#')[1]}`\n\n          this.scrollTo(target, options)\n        }\n      }\n    }\n\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      )\n\n      if (internalLink) {\n        this.reset()\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        this.limit > 0 &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      programmatic = true, // called from outside of the class\n      lerp = programmatic ? this.options.lerp : undefined,\n      duration = programmatic ? this.options.duration : undefined,\n      easing = programmatic ? this.options.easing : undefined,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start', '#'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n\n        if (!node) {\n          if (target === '#top') {\n            target = 0\n          } else {\n            console.warn('Lenis: Target not found', target)\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n"],"names":["$8ecb29f509dc0bd0$var$clamp","min","input","max","Math","$8ecb29f509dc0bd0$var$Animate","isRunning","value","from","to","currentTime","lerp","duration","easing","onUpdate","advance","deltaTime","completed","linearProgress","easedProgress","x","y","lambda","t","exp","round","stop","fromTo","lerp2","onStart","$8ecb29f509dc0bd0$var$Dimensions","wrapper","content","autoResize","debounce","debounceValue","callback","timer","debouncedResize","resize","args","context","clearTimeout","setTimeout","apply","Window","window","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","width","height","scrollHeight","scrollWidth","destroy","disconnect","removeEventListener","onWrapperResize","onContentResize","innerWidth","innerHeight","clientWidth","clientHeight","limit","$8ecb29f509dc0bd0$var$Emitter","events","emit","event","callbacks","i","length","on","cb","push","filter","off","$8ecb29f509dc0bd0$var$LINE_HEIGHT","$8ecb29f509dc0bd0$var$listenerOptions","passive","$8ecb29f509dc0bd0$var$VirtualScroll","element","options","wheelMultiplier","touchMultiplier","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","touchStart","lastDelta","emitter","clientX","clientY","targetTouches","deltaX","deltaY","deltaMode","multiplierX","multiplierY","$8ecb29f509dc0bd0$var$defaultEasing","pow","$8ecb29f509dc0bd0$export$2e2bcd8739ae039","_isScrolling","_isStopped","_isLocked","_preventNextNativeScrollEvent","_resetVelocityTimeout","_rafId","isTouching","time","userData","lastVelocity","velocity","direction","targetScroll","animatedScroll","animate","dimensions","virtualScroll","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","naiveDimensions","stopInertiaOnNavigate","lenisVersion","updateClassName","actualScroll","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","checkOverflow","rootElement","onTransitionEnd","requestAnimationFrame","raf","cleanUpClassName","cancelAnimationFrame","e","CustomEvent","isScrolling","stopPropagation","dispatchScrollendEvent","dispatchEvent","bubbles","detail","lenisScrollEnd","overflow","property","isHorizontal","getComputedStyle","includes","internalStop","internalStart","propertyName","setScroll","scroll","scrollTo","left","behavior","top","anchorElements","path","composedPath","node","HTMLAnchorElement","getAttribute","anchor","find","href","target","split","host","location","reset","button","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isClickOrTap","isStopped","isLocked","isUnknownGesture","slice","indexOf","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","delta","abs","isSyncTouch","isTouchEnd","hasTouchInertia","sign","programmatic","lastScroll","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","querySelector","console","warn","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","maxScroll","hasOverflow","isScrollable","Date","now","cache","_lenis","computedStyle","overflowXString","overflowX","overflowYString","overflowY","isScrollingX","isScrollingY","scrollLeft","scrollTop","willScroll","scrollX","scrollY","d","n","progress","isSmooth","className","trim","replace","$44dff8ba698aec05$var$e","s","Array","$44dff8ba698aec05$var$s","Symbol","iterator","call","next","bind","isArray","toString","name","test","done","TypeError","$44dff8ba698aec05$var$i","Object","assign","arguments","hasOwnProperty","$44dff8ba698aec05$var$n","scrollElements","rootMargin","root","o","IORaf","observer","_init","prototype","IntersectionObserver","forEach","$el","isIntersecting","isAlreadyIntersected","_setInview","_setOutOfView","unobserve","setInteractivityOn","setInview","setInteractivityOff","setOutOfView","attributes","scrollRepeat","$44dff8ba698aec05$var$o","reduce","$44dff8ba698aec05$var$l","$44dff8ba698aec05$var$a","r","l","a","id","c","subscribeElementUpdateFn","h","unsubscribeElementUpdateFn","u","needRaf","scrollOrientation","f","lenisInstance","intersection","metrics","currentScroll","translateValue","lastProgress","isInview","isInteractive","isInFold","isFirstResize","getWindowSize","getMetricsStart","getMetricsSize","startPositionHandlers","middle","end","fold","endPositionHandlers","scrollClass","dataset","scrollOffset","scrollPosition","scrollCssProgress","scrollEventProgress","scrollSpeed","parseFloat","scrollCall","scrollIgnoreFold","scrollEnableTouchSpeed","offsetStart","offsetEnd","bcr","_resize","onResize","onRender","smooth","_computeProgress","isNaN","transform","classList","add","_getScrollCallFrom","_dispatchCall","remove","_computeMetrics","_computeIntersection","v","m","g","parseInt","p","b","I","_setCssProgress","_setCustomEventProgress","way","$44dff8ba698aec05$var$c","$44dff8ba698aec05$var$h","triggerRootMargin","rafRootMargin","$scrollContainer","triggeredScrollElements","RAFScrollElements","scrollElementsToUpdate","IOTriggerInstance","IORafInstance","error","querySelectorAll","toElementArray","_subscribeScrollElements","concat","_unsubscribeAllScrollElements","removeScrollElements","Set","has","splice","_unsubscribeElementUpdate","addScrollElements","_checkRafNeeded","_subscribeElementUpdate","map","join","$44dff8ba698aec05$export$2e2bcd8739ae039","lenisOptions","autoStart","scrollCallback","initCustomTicker","destroyCustomTicker","rafPlaying","coreInstance","rafInstance","isTouchDevice","_onRenderBind","_onResizeBind","_onScrollToBind","_originalOnContentResize","_originalOnWrapperResize","locomotiveScrollVersion","_onRender","_onScrollTo","_onResize","navigator","maxTouchPoints","setAttribute","_bindEvents","_unbindEvents","_bindScrollToEvents","_unbindScrollToEvents","currentTarget","_raf","$d2967b03e75792e9$var$scroll","container","el","update","IO","_ref","_ref$rootMargin","_ref$root","this","_proto","_this","entries","entry","$targetItem","item","_step","_iterator","_createForOfIteratorHelperLoose","$scrollElement","scrollElement","mapRange","inMin","inMax","outMin","outMax","closestNumber","array","prev","curr","PROGRESS_CSS_VAR","ScrollElement","_this$$el$dataset$scr","_this$$el$dataset$scr2","_this$$el$dataset$scr3","_this$$el$dataset$scr4","_this$$el$dataset$scr5","wSize","viewport","size","undefined","_ref2","_ref3","metricsStart","metricsSize","_offset$0$trim","_offset$","_offset$1$trim","_offset$2","_scrollPosition$0$tri","_scrollPosition$","_scrollPosition$1$tri","_scrollPosition$2","scrollPositionStart","scrollPositionEnd","viewportStart","viewportEnd","startHandler","endHandler","forcedProgress","currentProgress","customEventName","customEvent","closestIntersectionValue","ATTRIBUTES_THAT_NEED_RAF","Core","$scrollElements","$scrollElementsArr","ioRoot","_step2","_iterator2","$oldContainer","$scrollElementsToRemove","$scrollElementsToRemoveSet","index","targetScrollElementToUpdate","targetScrollElement","scrollElementItem","$newContainer","ids","fromIndex","toObserve","scrollElementInstance","_step3","_iterator3","scrollElementToUpdate","elements","attributesThatNeedRaf","removeAttribute","attributeToRemove","attribute","_iterator4","_step4","LocomotiveScroll","_temp","_ref$lenisOptions","_ref$autoStart","_ref$scrollCallback","Lenis","_extends","_this$lenisInstance","_this2","_this2$coreInstance","_this3","$container","_this$lenisInstance2","_this4","$rootContainer","$scrollToElements","_this$lenisInstance3","_this5","_this$coreInstance","_this$lenisInstance$s","_this$lenisInstance4","_this$lenisInstance5","_this$coreInstance2","_this$lenisInstance$s2","_this$lenisInstance6","_event$currentTarget","_this$lenisInstance7","$target","_this$lenisInstance8","_this$lenisInstance9","_this$coreInstance3","_this$coreInstance4","_this6","_this$lenisInstance0","_this7"],"version":3,"file":"bads.6c37a0a2.js.map"}